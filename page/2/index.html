<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Jo Member</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Jo Member"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Jo Member"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="끄적끄적"><meta property="og:type" content="blog"><meta property="og:title" content="Jo Member"><meta property="og:url" content="https://jo-member.github.io/"><meta property="og:site_name" content="Jo Member"><meta property="og:description" content="끄적끄적"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://jo-member.github.io/img/og_image.png"><meta property="article:author" content="jo-member"><meta property="article:tag" content="AI, Deep_learning, python, nlp, cv"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jo-member.github.io"},"headline":"Jo Member","image":["https://jo-member.github.io/img/og_image.png"],"author":{"@type":"Person","name":"jo-member"},"description":"끄적끄적"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Jo Member" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/jo-member"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-02-16T15:00:00.000Z" title="2020. 2. 17. 오전 12:00:00">2020-02-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-04-21T17:38:05.169Z" title="2021. 4. 22. 오전 2:38:05">2021-04-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Boostcamp/">Boostcamp</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/17/2021-02-15-Boostcamp18.1/">Day18) Sequence to sequence with Attention</a></h1><div class="content"><h1 id="Sequence-to-sequence"><a href="#Sequence-to-sequence" class="headerlink" title="Sequence to sequence"></a>Sequence to sequence</h1><br/>

<p>\</p>
<h2 id="Seq2Seq-Model"><a href="#Seq2Seq-Model" class="headerlink" title="Seq2Seq Model"></a>Seq2Seq Model</h2><p>Ex) Are you free tomorrow?</p>
<p><img src="assets/images/image-20210217110021239.png" alt="image-20210217110021239"></p>
<p>서로 paramter를 share하지 않는 2개의 별개의 RNN model을 (보통 LSTM) 쓴다. 각각의 RNN을 Decoder, Encoder로 사용한다.</p>
<p>Encoder의 마지막단의 output을 vertorize 시켜준후 decoder의 input에는 SOS token, hidden state에는 encoder의 output을 넣어준다.</p>
<h2 id="Seq2Seq-with-Attention"><a href="#Seq2Seq-with-Attention" class="headerlink" title="Seq2Seq with Attention"></a>Seq2Seq with Attention</h2><p>앞에서의 RNN을 사용한 model은 hidden state vector의 dimesion이 정해져 있어서 입력문장의 길이가 길어지면 마지막 time step에 있는 hiddenstate vector에 앞서 나왔던 많은 정보들이 잘 담겨져 있지 않다.</p>
<p>아무리 이 LSTM에서 longterm dependency를 해결하려 해도구조상의 문제 때문에 해결하기에 매우힘들다</p>
<p>따라서 이러한 문제를 해결하기 위해서 seq2seq에서 Attention을 활용할 수 있다. Attention은 encoder의 각각의 hidden state vector를 전체적으로 decoder에 제공해주고 decoder에서는 그때그때 필요한 encoder의 hidden state vector를 가져가서 사용한다</p>
<p>decoder의 hidden state vector가 encoder의 어떤 hidden state vector를 가져올지를 결정하게 된다. 이거는 각각을 내적해보아서, 내적에 기반한 유사도를 판별하게 되고 이결과를 softmax에 통과 시켜서 확률값을 얻어내고 이를 각각의 가중치로 사용하여 이들의 가중평균으로서 나오는 하나의 encoding vector를 얻어낼수 있다!!!!!! 이러한 가중평균으로 나온 하나의 vector를 우리는 context vector라고 부른다.  </p>
<p><img src="assets/images/image-20210217111855000.png" alt="image-20210217111855000"></p>
<p>이후에 decoder hidden state vector와 context vector가 concatnate 되어 output layer의 입력으로 들어가게 되고 다음나올 단어를 예측할 수 있게 된다</p>
<p>이러한 과정들을 EOS가 나올때 까지 반복한다.</p>
<p>잘못된 단어를 전단계에서 예측을 하더라도 다음단계에는 올바른 ground truth를 넣어주기 떄문에 하나가 틀려도 이후가 망가지지 않는다.  학습이 끝난후 이 잘못된 단어를 다시 넣어준다. 또한 It’s teacher forcing.</p>
<p>Teacher forcing이 아닌 방식이 학습후에 우리가 실제로 사용할때와 비슷하다.</p>
<p>Teacher forcing때는 ground truth를 넣어주어야 하기 때문에학습속도가 빠르다</p>
<p>학습의 전반부에는 teacher forcing을 사용후  어느정도 학습이 되면, 이전의 output을 다시 입력으로 넣어주는 방식으로 진행한다.</p>
<br/>

<p><img src="assets/images/image-20210217120519836.png" alt="image-20210217120519836"></p>
<p>이처럼 유사도를 측정하는 과정에서 사용되는 내적은, 3가지의 종류로 계산해 낼 수 있다.</p>
<p>2번째인 general 방식으로 게산하는 것을 행렬으로 생각해보자.내적을 기반한 계산을 행렬의 곱으로 생각해보면,  </p>
<p><img src="assets/images/image-20210217120331715.png" alt="image-20210217120331715"></p>
<p>대각행렬의 성분들은 같은 차원끼리의 가중치를 나타내고, 나머지 값들은 다른 차원끼리의 곱해진 값들의 가중치를 나타낸다</p>
<p>이처럼 간단한 내적으로 정의된 형태의 유사도를 그가운데 학습가능한 parameter를 추가함으로서 새롭게 score를 계산했다.</p>
<p>이게 바로 general한 dot product이다.</p>
<br/>

<p>다음으로 concat을 사용한 score 측정 방식을 보자</p>
<p><img src="assets/images/image-20210217120926535.png" alt="image-20210217120926535"> </p>
<p>이처럼 2개의 vector를 concat시켜 MLP의 입력으로 넣어준 후 non linear activation function을 적용하여 값을 구해낸다.</p>
<p><img src="assets/images/image-20210217121132215.png" alt="image-20210217121132215"></p>
<p>이수식을 간단하게 보면 Wa는 1번째 layer의 가중치, 그이후에 tanh를 적용한 후 v를 곱해주는데 이는 우리가 최종적으로 얻어야할 output이 scalar값이기 떄문에 v는 row의 형태를 띄어야 한다. 따라서 tranpose를 시켜준것을 확인 할 수 있다.</p>
<br/>

<p>그렇다면 이들의 paramter은 어떠힌 방식으로 update될까?</p>
<p>결국은 이러한 유사도를 구하는데 필요한 parameter들또한 backpropagation을 통하여 선형변환 행렬들이 학습되게 된다.</p>
<br/>

<h2 id="Attention-is-great"><a href="#Attention-is-great" class="headerlink" title="Attention is great"></a>Attention is great</h2><ul>
<li><p>Attention significantly impoves NMT performace</p>
<p>어떠한 한 부분에 집중할 수 있게 해주었다</p>
</li>
<li><p>It solves bottle neck problem</p>
<p>encoder의 마지막을 사용했어야 해서 생기는 long term dependency를 해결</p>
</li>
<li><p>Gradient vanishing의 문제를 해결하였다.</p>
</li>
<li><p>Attention provides some interpretability</p>
<p>우리가 transform과정에서 모델이 어떠한 부분에 집중 했는지를 확인 할 수 있다. Allignment를 NN이 스스로 배우는 현상을 보여주게 된다.</p>
</li>
</ul>
<h1 id="Beam-search"><a href="#Beam-search" class="headerlink" title="Beam search"></a>Beam search</h1><ul>
<li>test과정에서 더 좋은 결과를 얻을수 있게 해주는 하나의 방법</li>
</ul>
<h2 id="Greedy-decoding"><a href="#Greedy-decoding" class="headerlink" title="Greedy decoding"></a>Greedy decoding</h2><p>가장 높은 확률을 가지는 단어 1개를 선택하는 방법</p>
<p>이렇게 되면 어떠한 단어를 잘못 생성해내었을때 다시 뒤로 돌아갈수 없어 최적의 예측값을 내지 못하게 된다</p>
<p>이를 해결하기 위해서 다양한 방법들이 제시된다</p>
<br/>

<h2 id="Exhaustive-Search"><a href="#Exhaustive-Search" class="headerlink" title="Exhaustive Search"></a>Exhaustive Search</h2><p>첫번째 생성하는 단어가 가장큰 확률이였다고 해도 뒷부분에서 나오는 확률값 가장큰 확률값이 아닌 경우가 발생될수가 있다.</p>
<p><img src="assets/images/image-20210217125708440.png" alt="image-20210217125708440"></p>
<p>이는 결국 time step t 까지의 가능한 모든경우를 따져서 이는 곧 vocab가지수가 되고 V^t^가 가능한 모든 경우의 수이다. 이는 너무 큰 숫자이기 때문에 beam search를 쓰게된다</p>
<br/>

<h2 id="Beam-search-1"><a href="#Beam-search-1" class="headerlink" title="Beam search"></a>Beam search</h2><p>매 time step마다 모든 경우의 수를 고려하는게 아니라, 우리가 정해놓은 k개의 가능하 가짓수를 고려하고 마지막까지 decoding을 진행한후 k개의 candidate중에서 가장확률값이 높은걸 선택하는 방식이다.</p>
<p>이를 우리는 hypothesis (가설)이라고 부른다</p>
<p>k는 beam size이 일반적으로 5~10으로 설정하게 된다.</p>
<p> <img src="assets/images/image-20210217130106952.png" alt="image-20210217130106952"></p>
<p>확률들의 곱셈 앞에 log를 붙이게 되면 곱들이 모두 덧셈이 된다. 여기서 log함수 단조증가이기 때문에, 큰값이 큰값을 가진다.</p>
<p>ex) k = 2</p>
<ol>
<li> k가 2이기 때문에 가장 확률값이 높은 2개의 단어를 뽑는다</li>
</ol>
<p><img src="assets/images/image-20210217130719246.png" alt="image-20210217130719246"></p>
<ol start="2">
<li>이중 값이 큰걸 계속해서 선택해 나감</li>
</ol>
<p><img src="assets/images/image-20210217130908355.png" alt="image-20210217130908355"></p>
<ul>
<li>greedy의 경우 end token이 나왔을때가 종료이지만, beam search에서는 서로다른 시점에서 end token이 생성되기 때문에, 각각이 끝날때마다 한곳에 저장해준다.</li>
</ul>
<p>우리가정한 T라는 시간까지 수행하거나, 완료된 hypothesis가 n개가 되었을때 beam search를 중단한다.</p>
<p>우리가 고려하는 hypotheses의 길이가 다를때는 상대적으로 짧은 길이의 확률이 높은것이고, 길면 낮을것이다. </p>
<p>이를 고려해 주기 위해서는 각 joint prob을 문장의 길이로 나눔으로서 해결해줄 수 있다.</p>
<h2 id="BLEU-score"><a href="#BLEU-score" class="headerlink" title="BLEU score"></a>BLEU score</h2><ul>
<li>생성 model의 점수를 평가하기 위한 척도</li>
<li>고정된 위치에서 정해진 단어가 나와야 된다는 평가방식은 매우 나쁜 방식이다.</li>
</ul>
<p>ex)</p>
<p>Reference : Half of my heart is in Havana ooh na na</p>
<p>Predicted :  Half as my heart is in Obama ohh na</p>
<p>Precision(실제로 위치상관없이 겹치는 단어가 몇개인가) = #(correct words)/length_of_prediction = 7/9</p>
<p>Recall(재현률)  = #(correct words)/length_of_reference = 7/10</p>
<p>F-measure = (precision x recall) / 0.5(precision + recall) (두 값들의 조화평균)</p>
<p>보다 작은 작은 값에 가깝게 구하는 방식 -&gt; 조화평균</p>
<p>이렇게 구한 값들은 순서를 보장하지 않기 때문에 BLEU가 나왔다.</p>
<h3 id="BiLingual-Evaluation-Understudy"><a href="#BiLingual-Evaluation-Understudy" class="headerlink" title="BiLingual Evaluation Understudy"></a>BiLingual Evaluation Understudy</h3><p><strong>Ngram</strong>이란걸 사용했다. 연속된 N개의 단어로 이루어진 문구를 matching하여점수로 반영하였다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-02-15T15:00:00.000Z" title="2020. 2. 16. 오전 12:00:00">2020-02-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-04-21T17:35:39.773Z" title="2021. 4. 22. 오전 2:35:39">2021-04-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Boostcamp/">Boostcamp</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/16/2021-02-15-Boostcamp16.1/">Day17) RNN</a></h1><div class="content"><br/>

<h1 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h1><p>서로다른 time step에서 들어오는 입력 데이터를 처리할때, 매번 반복되는 동일한 rnn module을 호출한다.<img src="/assets/images/image-20210216103443317.png" alt="image-20210216103443317"></p>
<p><img src="/assets/images/image-20210216103929384.png" alt="image-20210216103929384"></p>
<p>각 단어별로 품사를 예측해야 되는 경우 -&gt; 매 time step마다 y를 output으로</p>
<p>어떠한 문장의 긍부정을 판별하는 경우 -&gt; 최종 time step의 y만이 output으로</p>
<p>모든 time step에서 같은 parameter W를 공유한다</p>
<br/>

<p>주어진 vector가 3차원의 입력벡터로 주어졌을때 h<del>t-1</del>은 2차원이라고 가정하자 </p>
<p>x<del>t</del>와 h<del>t-1</del>를 같이 입력으로 받아서 f<del>W</del>에 넣어주면, h<del>t</del>가 나오게 된다<img src="/assets/images/image-20210216111255186.png" alt="image-20210216111255186"></p>
<p>현재 timestep t에서추가적인 outputlayer를 만들고 h<del>t</del>에 W<del>hy</del>를 곱해서 y<del>t</del>를 얻어낸다.</p>
<h2 id="Types-of-RNN"><a href="#Types-of-RNN" class="headerlink" title="Types of RNN"></a>Types of RNN</h2><p><strong>One-to-one</strong></p>
<p>입출력 모두가 sequence data인 경우에 입출력이 단 1개인</p>
<p><strong>one-to-many</strong></p>
<p>image captioning에서 이러한 구조를 띈다. </p>
<p>초기에 입력이 한번 들어가고 이후 입력으로는 0으로 채워진 tensor를 입력으로 주게된다</p>
<p><strong>many-to-one</strong></p>
<p>최종값을 마지막에서야 내주는</p>
<p>ex) I love movie에서 RNN이 처리한후 마지막의 h<del>t</del>를 봄으로서 긍부정을 예측하게 된다. 길이가 달라진다면 RNN CELL이 그만큼 확장이된다</p>
<p><strong>many-to-many</strong></p>
<ol>
<li>ex) machine translation</li>
</ol>
<img src="/assets/images/image-20210216120729609.png" alt="image-20210216120729609" style="zoom:50%;" />

<ol start="2">
<li>Ex) POS, vidio의 frame이 sequence대로 주어질때</li>
</ol>
<h2 id="Character-level-Language-Model"><a href="#Character-level-Language-Model" class="headerlink" title="Character-level Language Model"></a>Character-level Language Model</h2><ul>
<li>Example of training sequence “hello”</li>
<li>vocab = [h,e,l,o]</li>
<li>각각의 character은 one-hot-vector로 표현이 가능하다</li>
</ul>
<img src="/assets/images/image-20210216121012818.png" alt="image-20210216121012818" style="zoom:50%;" />

<h2 id="Back-propagation-through-time-BPTT"><a href="#Back-propagation-through-time-BPTT" class="headerlink" title="Back propagation through time (BPTT)"></a>Back propagation through time (BPTT)</h2><p>Whh,Why,Wxh 와 같은 parameter들을 학습한다</p>
<p>sequence전체를 한번에 학습하기에는 physical적인 한계가 존재하기 때문에 군데군데 짤라서 제한된 길이의 sequenc 만으로 학습을 진행한다</p>
<p>매  time step마다 hidden state vector가 거의 모든 정보를 담고 있다. 그렇다면 만약에 hidden state의 차원이 3차원이라면, 우리가 원하는 정보가 그중 어느 node에 담겨져 있을까? 이걸 역추적. 첫번째 ht의 node를 고정해 놓고 이후의 변화들을 봄</p>
<br/>

<p>정작 지금까지 배운 vanila RNN은 잘 활용하지 않는다. 이유는 만약 긴거리에 있는 정보가 매우 중요할 경우 back propagtion으로 구해지기 때문에 gradient vanishing이나 gradient explode가 일어나게 된다. </p>
<p><img src="/assets/images/image-20210216124337509.png" alt="image-20210216124337509"></p>
<p>gradient값이 증폭되고있다</p>
<br/>

<h1 id="LSTM-amp-GRU"><a href="#LSTM-amp-GRU" class="headerlink" title="LSTM &amp; GRU"></a>LSTM &amp; GRU</h1><h2 id="Long-short-term-Memory"><a href="#Long-short-term-Memory" class="headerlink" title="Long short-term Memory"></a>Long short-term Memory</h2><p>보다 효과적으로  long term dependency를 처리할수 있게끔하기 위해</p>
<p>h<del>t</del>를 단기 기억소자로 생각할 수 있으며, 이러한 단기기억을 얼마나 길게 끌고갈 것이지를 판별해주는 역할들을 가진 gate들로 이루어져 있다</p>
<p>전 time step에서 넘어오는 정보가 2가지의 서로다른 vector가 들어오게 된다.</p>
<p>위에 들어오는 vector : C<del>t</del></p>
<p>아래쪽에 들어오는 vecor : h<del>t</del></p>
<p>Í<img src="/assets/images/image-20210216125806943.png" alt="image-20210216125806943"></p>
<p>C<del>t-1</del> 이전 cell state와 이전 state의 hidden state를 입력으로 받아 현재의 cs와 ss를 내준다. Hidden state vector은 cell state vector중에 노출되는 정보를 담은, 한번 필터링 된 vector이다.</p>
<p><img src="/assets/images/image-20210216130159755.png" alt="image-20210216130159755"></p>
<p>여기서 sigmoid의 결과와 곱해지면 얼마만큼 이전의 원래값을 반영할지를 결정하는 역할을 한다. 마지막 tanh를 통해 나오는 값은 현재 time step에서 LSTM에서 계산되는 유의미한 정보라고 생각할 수 있다.</p>
<ol>
<li><p>Forget gate</p>
<p><img src="/assets/images/image-20210216131518759.png" alt="image-20210216131518759"></p>
</li>
</ol>
<p>위를 보면 이전의 hidden state와 현재의 x<del>t</del>를 입력으로 받아 sigmoid 적용후 3차원의 vector가 나오게 되었다. 이렇게 나온 vector와 이전의 cell state의 element wise product를 해주어서 이전의 cell state를 얼마만큼 반영할지를 게산해 주었다.</p>
<ol start="2">
<li>Gate gate</li>
</ol>
<p><img src="/assets/images/image-20210216132213172.png" alt="image-20210216132213172"></p>
<p>C<del>t</del>에 더해주어야 하는 값을 바로 더해주지 않고 i<del>t</del>를 곱해서 더해준다</p>
<ol start="3">
<li>Output gate</li>
</ol>
<p><img src="/assets/images/image-20210216132521862.png" alt="image-20210216132521862"></p>
<p>이제 cell state vector C<del>t</del>로 hidden state vector h<del>t</del>를 만들어준다. 앞서 sigmoid를  적용한 값또한 tanh를 거친 Celll state에 곱한값에 곱해주어 적절한 비율만큼 값을 작게 만들어주어 최종적인 h<del>t</del>를 만들어주게 된다.</p>
<p>h<del>t</del>는 다음 rnn의 hidden state로 들어가는 동시에 현재 time step에서 예측을 수행할때 이걸 output layer에 넘겨주어 예측값을 생성해 낸다</p>
<h2 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h2><p>LSTM에서 2가지 종류의 vector로 존재하던 cell state와 hidden state vector를 일원하 하여 하나의 vector만이 존재하게 한다는게 특징이다. 하지만 전체적인 동작원리는 거의 비슷</p>
<p><img src="/assets/images/image-20210216142225794.png" alt="image-20210216142225794"></p>
<p>forget gate대신 1-z<del>t</del>를 사용, i<del>t</del>대신 z<del>t</del>를 사용</p>
<p>input gate가 커질수록 forget gate의 값이 점차 작아지게 되어 결과적으로 이전 hidden state vector를 더 적게 반영하는 것이고, vice versa</p>
<ol>
<li>hidden state를 일원화 하였다</li>
<li>2개의 독립된 gate를 통하여 동작되었던 model을 하나의 gate만으로 줄여 계산량과 메모리 사용량을 줄였다.</li>
</ol>
<p>정보를 주로담는 cell state가 update되는 과정이 행렬의 계속적인 곱의 연산이 아니라 그때그때 서로다른 gate를 거쳐가며 update되기 때문에 gradient vanishing이 사라진다. 덧셈연산은 이전의 state를 복사해주어 gradient를 유지하는 역할을 한다고 볼 수도 있다. RNN은 다양한 길이를 가질수 있는 유연한 형태의 deep learning구조.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-02-13T15:00:00.000Z" title="2020. 2. 14. 오전 12:00:00">2020-02-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-04-21T17:35:34.969Z" title="2021. 4. 22. 오전 2:35:34">2021-04-22</time></span><span class="level-item"><a class="link-muted" href="/categories/PaperReview/">PaperReview</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/14/2021-02-14-GPT/">Paper Review) Improving Language Understanding by Generative Pre-Training</a></h1><div class="content"><br/>

<p>이번에는 openai에서 발표한 논문인 GPT를 review해보겠다</p>
<p>GPT3는 이전에 review한 transformer구조를 활용하여 Language understanding을 효과적으로 만들었다.</p>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><br/>

<p>자연어를 이해는 text추론, 질문에 대한 대답, 의미의 유사성 평가, 문서분류등을 포함하고 있다. 라벨링 되지 않은 text들을 매우 넘처나지만, 특정 task의 학습을 위해 labed된 text들은 매우 적기때문에 좋은 모델을 학습시키는것은 매우 힘들다.  Language 모델을 unlabled된 text로 <em>generative pretrain</em>을 한이후 각각의 task에 맞게 fine-tunning을 하였다.  이러한 많은 unlabed text를 사용하여 학습하였다. 이전의 연구와는 달리,필요한 task에 fine-tuning하여 응용하는 것이 매우 효과적이다.</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><br/>

<p>Raw text를 사용하여 효과적인 NLP 학습을 하기위해서는 지도학습에 대한 의존성을 완화해야 한다. 많은 딥러닝 방법들은 labeled된 data를 사용해야 해서 한계가 존재한다. 이러한 상황에서 unlabed된 data는 시간과 노력이 필요한 annotation을 모으는 작업들을 대체할 수 있다. 만약 고려가능한 지도가 가능한 상황이라면, unsupervised 방법은 model의 성능을 증가시킬 수 있다. 이러한 방식은 pretrained된 word embedding을 사용하여 성능을 높이는것과 비슷한 이유이다.</p>
<p>unlabed된 data로 word-level의 정보보다 많은 정보를 활용하는것은 2가지 이유에서 매우 어렵다</p>
<ol>
<li>어떠한 종류의 optimization objective가 가장 효과적으로 text를 표현할수 있을까 가 매우 unclear하다</li>
<li>우리가 원하는 특정 task에 효과적으로 적용하는 방법에 대한 의견이 일치가 되징 않았다. 현재 존재하는 방법은 model에 특정한 task-specific한 변화를 가하는 것과, 복잡한 학습방법,그리고 학습을 도와주는 몇몇 learning objective들을 넣어주는, 이러한 방법들의 combination이다</li>
</ol>
<p>이러한 불확실성은 language processing에서의 효과적인 semi-supervised learning을 발전시키기 힘들게 만든다.</p>
<br/>

<p>이 논문에서는 unsupervised pre-training과 supervised fine-tunning을 조합한 방법을 사용하여 semi-supervised approach를 하였다. 목적은 가장 보편적으로 학습하여 약간의 응용으로 다양한 분야에 적용시키는것이다. </p>
<p>2-stage로 나누어 train하였다</p>
<ol>
<li>초기 parameter를 학습하기 위해 unlabeled data를 사용하여 pre-train 하였다 / with transformer</li>
<li>우리는 이 parameter들을 특정한 task에 맞는 supervised objective 학습에 사용하였다.</li>
</ol>
<p>또한 model에서 <em>Transformer</em>를 사용하여 long-term dependencies를 해결하였다.</p>
<br/>

<h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p><strong>Semi-supervised learning for NLP</strong></p>
<p>우리의 work는 Semi-supervied learning의 범주안에있다. 이 ssl은 sequence labeling, text 분류등에 쓰이면서 큰 관심을 받고 있다. 가장 초기에는 unlabeled data를 supervised learning의 feature로 사용하여 word나 phrase level의 통계를 계산하는데 사용되었다. 최근 몇년동안 word-embedding이 얼마나 좋은지 밝혀냈다. 이러한 접근은 word-level의 정보를 특정한 high-level에 맞추어 준다. 최근에는 word-level이 아닌 phrase나 sentence level의 embedding을 사용하여 text를 다양한 target task의 vector representation을 나타내 주었다.</p>
<br/>

<p><strong>Unsupervised pre-training</strong></p>
<p>Unsupervised pre-training은 supervised learning을 바꾸는거 보다는 좋은 initialization을 찾는게 목적이다. 각각의 연구들은 image classification과 regression task의 기술이 사용되었다. Pre-training은 정규화 과정에서 generalization성능을 올려준다. </p>
<p>우리의 연구는 language modeling으로 model을 pre-train한후 task에 맞게 fine-tuning해주는 것이다. Pre-training이 언어적인 정보를 잘 잡아낼수 있지만,이전연구에서 사용된 LSTM을 사용하는 것은 긴 data를 해석하지 못한다는 단점이 존재한다. 따라서 우리는 Transformer를 사용하였다.또다른 연구에서는 몇몇 보조적인 feature들을 삽입해주어 성능을 향상시켰지만, 이는 새로운 parameter의 증가를 야기한다. 우리의 GPT는 transfer과정에서 최소한의 수정만을 필요로 한다.</p>
<br/>

<p><strong>Auxiliary training objectives</strong></p>
<p>여러 보조적인 unsupervised training은 semi-supervised learning의 대채적인 형태이다. 이전의 연구에서는 다양한 종류의 보조적인 NLP방법론(POS tagging, chunking,등등등)을 사용하였다. 최근 또다른 연구는 보조적인 language model를 추가하여 sequence labeling의 성능향상을 이야기 하였다. </p>
<br/>

<h2 id="3-Framework"><a href="#3-Framework" class="headerlink" title="3. Framework"></a>3. Framework</h2><p>학습과정은 2개의 stage로 나누어져 있다</p>
<ol>
<li>unlabeled된 큰 말뭉치를 사용하여 가장 범용적인 language model을 학습하는 stage</li>
<li>이후 labeled data를 사용한 fine-tuning stage</li>
</ol>
<br/>

<p><strong>3.1 Unsupervised pre-training</strong></p>
<p>unsupervised의 token들 = <img src="assets/images/image-20210214174726972.png" alt="image-20210214174726972">이 주어지고, 이어지는 likelihood를 maximize하기위해 보편적인 language model을 사용한다.</p>
<img src="assets/images/image-20210214174902969.png" alt="image-20210214174902969" style="zoom:150%;" />

<p>k는 context의 size이고, conditional prob P는 NN을 사용하여 modeled</p>
<p>이들은 모두 SGD를 사용하여 training했다.</p>
<p><em>multi-layer Transformer decoder</em>를 사용했다.</p>
<p>이 model은 input context tokens에 multi-headed self-attention을 활용하였고, 이후에 position-wise feedforward layer를 적용하여 target token에대한 output distribution을 구한다.</p>
<p><img src="assets/images/image-20210214180732689.png" alt="image-20210214180732689"></p>
<p>U는 token의 context vector이고, n은 layer의 숫자, W<del>e</del>는 token embedding matrix, W<del>p</del>는 position embedding matrix이다.</p>
<br/>

<p><strong>3.2 Supervised fine-tuning</strong></p>
<p>model을 train한후, supervised target test에 맞추어서 parameter를 적용한다. labeled된 dataset C(각각은 input token의 sequence로 이루어짐 ((x^1^,…,x^m^) and label y )) </p>
<p>Input은 pre-trained된 model을 통과하여 최종 transformer block의 activation인 h<del>l</del>^m^을 얻어내고, 이후에 linear output layer에 W<del>y</del>와 함께 들어간다. </p>
<p><img src="assets/images/image-20210214181504691.png" alt="image-20210214181504691"></p>
<p>이는 이후의 objective를 maximize하게 한다.</p>
<p><img src="assets/images/image-20210214181541269.png" alt="image-20210214181541269"></p>
<p>보조적인 장치로 language modeling을 사용하여 fine-tuning을 하는것은 (1) generalization성능을 높힌다 (2) 수렴속도를 높힌다. 우리는 아래의 objective를 optimize한다</p>
<p><img src="assets/images/image-20210214181938559.png" alt="image-20210214181938559"></p>
<p>Fine-tuning중에 유일한 extra parameter은 W<del>y</del>와 구분token을 위한 embedding이다.</p>
<p><img src="assets/images/image-20210214182200590.png" alt="image-20210214182200590"></p>
<p><strong>3.3 Task-specific input transformations</strong></p>
<p>text classification가 같은 몇몇 분야에서, 위에서 묘사했던대로 우리의 model을 fine-tune할 수 있었다. 질의응답과, textual entailment와 같은 문제에는 input을 ordered sentence pairs, triplets of document, question, answer으로 해주었다. 우리의 pre-trained model이 연속적인 sequence에서 학습되었기 때문에, 이러한 문제들에는 약간의 맞춤 수정이 필요하다.  이전의 연구들은 transffered representation위에 특정 architecture를 삽입하는 형태로 학습해왔다. 이는 많은양의 cutomization이 필요하며 이러한 추가적인 특정 architecture에는 transfer learning을 사용하지 않았다. 대신 우리는 traveral-stple approach(input을 정렬된 sequence로 만들어)를 사용하여 우리의 pre-trained model이 학습할 수 있게 하였다. 이러한 input의 조정은 문제상황에 따라 architecture의 큰 수정을 하지 않아도 되게 한다. 모든 transformation은 randomly initialized된 start,ending token을 포함한다.</p>
<br/>

<ol>
<li>Textual entailment(문장의 포함관계) : 전제 p와 가설 h 중간에 delimiter token $를 삽입하여 합쳐주었다.</li>
<li>Similarity (문장의 유사도 평가) : 두개의 비교대상은 순서가 딱히 없다. 한마디로 동등한 level에서 비교해야 되기 때문에 모든 가능한 순서를 사용하고 transformer이후에 나오는2개의 h<del>l</del>^m^  을 합쳐준다.</li>
<li>Question Answering and Commonsense Reasoning (질의응답) : </li>
</ol>
<h2 id="3-Model-Atchitecture"><a href="#3-Model-Atchitecture" class="headerlink" title="3. Model Atchitecture"></a>3. Model Atchitecture</h2><br/>











<p>language model -&gt; label이 필요가 없다</p>
<p>주어진 단어들을 가지고 다음단어를 예측하는</p>
<ol>
<li><p>Generative model</p>
<p>Generative model</p>
<p>data가 많아 질수록 정확도가 높아진다</p>
</li>
<li><p>Discriminative model</p>
<p>타이타닉같은</p>
<p>데이터가 많지 않을때 패턴파악이 쉬워서 많이들 사용한다</p>
<p>한정된 data에 과적합 되기가 쉽다</p>
</li>
<li><p>sample된 data로는 왜곡된 판단을 할 수 있다</p>
</li>
</ol>
<p>GPT는 unlabeled된 data로</p>
<ol>
<li><p>Pretraining LM</p>
</li>
<li><p>finefuning</p>
<p>데이터만 task관련데이터로 학습 model은 그대로</p>
</li>
</ol>
<p>Naural Language Inference -&gt; entailment contradiction파악</p>
<p>질의응답</p>
<p>비슷한 문장 판별</p>
<p>주어진 문장을 그룹으로 분류하는</p>
<p>비지도 학습 label이 있는 data로 fine tunning한다.</p>
<p>기존 language model 학습 공식과 같다</p>
<p>transformer의 decoder로 구성</p>
<p>layer추가없이 pretrained LM</p>
<p>byte pair embedding을 사용하였다</p>
<p>신조어 오탈자에 약한 word embedding이 아닌</p>
<p>byte pair. —–&gt; hack,able, deep, learn, ing</p>
<p>이런식으로 embedding을 하였다.</p>
<p>data가 주어졌을떄</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-02-04T15:00:00.000Z" title="2020. 2. 5. 오전 12:00:00">2020-02-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-04-21T17:35:29.841Z" title="2021. 4. 22. 오전 2:35:29">2021-04-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Boostcamp/">Boostcamp</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/05/2021-02-05-Boostcamp15.1/">Day15) Generative Models</a></h1><div class="content"><br/>



<h1 id="Generative-Models"><a href="#Generative-Models" class="headerlink" title="Generative Models"></a>Generative Models</h1><br/>

<br/>

<ul>
<li>What I can not create, I do not understand</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://deepgenerativemodels.github.io/">https://deepgenerativemodels.github.io/</a></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><br/>

<ul>
<li>What does it mean to learn a generative model</li>
<li>generative model은 단순히 생성모델이 아니다 </li>
</ul>
<p>Suppose we have some images of dogs</p>
<p>We want to learn a probability distribution p(x) such that</p>
<ul>
<li><p>Generation : If we sample x<del>new</del> ~ p(x), x<del>new</del> should look like a dog</p>
<ul>
<li>implicit models</li>
</ul>
</li>
<li><p>Density estimation :p(x) should be high if x look like a dog (어떤이미지의 확률을 계산함)</p>
<p>이건 마치 image classification</p>
<ul>
<li>explicit models</li>
</ul>
</li>
<li><p>Unsupervised representation learning </p>
<p>특정 image가 어떤 특징을 가지고있는지를 학습</p>
</li>
</ul>
<h2 id="How-can-we-represent-p-x"><a href="#How-can-we-represent-p-x" class="headerlink" title="How can we represent p(x)??????"></a><strong>How can we represent p(x)??????</strong></h2><br/>

<ul>
<li><p>Bernoulli distribution</p>
<ul>
<li><p>D = {Heads, Tails}</p>
</li>
<li><p>Specify P(X = Head) = p, P(X = Tails) = (1-p)</p>
</li>
</ul>
</li>
<li><p>Categorical distribution</p>
</li>
</ul>
<p>ex) Modeling and RGB joint distribution</p>
<ul>
<li>(r,g,b) ~ p(R,G,B)</li>
<li>number of case = 256x256x256</li>
<li>parameters = 255x255x255 개가 필요</li>
</ul>
<p>하나의 RGB pixel만해도 parameter를 표현하려면 어마어마한 숫자의 parameter가 필요하다</p>
<h3 id="Structure-Through-Independence"><a href="#Structure-Through-Independence" class="headerlink" title="Structure Through Independence"></a>Structure Through Independence</h3><p>What if X1,….,Xn are independent and binary pixels</p>
<p>p(x1,…,xn) = p(x1)p(x2)…p(xn)</p>
<p>possible state : 2^n^</p>
<p>parameter : n개만 필요</p>
<p>만약 각각의 pixel이 독립적이라고 가정한다면 이렇게 parameter수가 줄어든다</p>
<p>근데 이건 너무 말이 안된다</p>
<p>따라서 Independence와 fully dependent사이의 절충안???</p>
<h3 id="Conditional-Independence"><a href="#Conditional-Independence" class="headerlink" title="Conditional Independence"></a>Conditional Independence</h3><p>Three Important Rule</p>
<p><img src="/assets/images/image-20210205102341270.png" alt="image-20210205102341270"></p>
<p>n개의 joint distrubution을 n개의 conditional distribution으로 바꾸고</p>
<p>z가 주어졌을때 x,y는 independent하다 -&gt;이게 가정 완전 xy가 independent한게 아니라 z가 주어졌을때 </p>
<p>y는 상관이없다 이런느낌</p>
<h3 id="Conditional-Independence-1"><a href="#Conditional-Independence-1" class="headerlink" title="Conditional Independence"></a>Conditional Independence</h3><p>Using the chain rule</p>
<p><img src="/assets/images/image-20210205103330254.png" alt="image-20210205103330254"></p>
<p>이 수식 도출에서 어떠한 수학적인 가정이 없이 chain rule만으로 구한 수식이다 따라서 fully independent와 parameter 개수는 같다</p>
<ul>
<li><p>p(x1) :1개</p>
</li>
<li><p>p(x2|x1) : 2개 (one per for p(x2|x1 = 0) and p(x2|x1 = 1))</p>
</li>
<li><p>p(x3|x1,x2) : 4개</p>
</li>
<li><p>Hence 1+2+2^2^+…+2^n-1^ = 2^n^-1</p>
</li>
</ul>
<p>i+1번쨰 pixel은 i번째 pixel에만 dependent하다 가정 : markov assumption</p>
<p><img src="/assets/images/image-20210205103602281.png" alt="image-20210205103602281"></p>
<p><img src="/assets/images/image-20210205111200710.png" alt="image-20210205111200710"></p>
<p>그 중간에 있는 걸 conditional independence를 잘 활용해서 중간의 parameter값을 얻어냈다</p>
<h2 id="Auto-regressive-Model"><a href="#Auto-regressive-Model" class="headerlink" title="Auto-regressive Model"></a>Auto-regressive Model</h2><ul>
<li><p>suppose we have 28x28 binary pixels</p>
</li>
<li><p>goal : p(x) = p(x1,x2….,x784)</p>
</li>
<li><p>how can we parametrize p(x)</p>
</li>
<li><p>use chain rule to get joint distribution</p>
</li>
<li><p>p(x<del>1:784</del>) = p(x<del>1</del>)p(x<del>2</del>|x<del>1</del>)p(x<del>2</del>|x<del>1:2</del>)……</p>
</li>
<li><p>이게 바로 auto-regressive model (i번째 pixel이 1~i-1까지 모든 history에 dependent한)</p>
</li>
<li><p>가장 중요한게 순서를 매기는 과정</p>
<p><strong>이미지에 순서???? —-&gt; 순서에 따라 성능이나 방법론이 달라질수 있다</strong></p>
</li>
</ul>
<h2 id="NADE-Neural-Autoregressive-Density-Estimator"><a href="#NADE-Neural-Autoregressive-Density-Estimator" class="headerlink" title="NADE : Neural Autoregressive Density Estimator"></a>NADE : Neural Autoregressive Density Estimator</h2><ul>
<li>p(x<del>i</del>|x<del>1:i-1</del>) = </li>
</ul>
<p>i번째 pixel을 1~i-1에 dependent하게 만든다  —–&gt; </p>
<p><strong>dependent 하다 ?</strong> 1-i-1번째 pixel값을 입력으로 받고 network를 통과시켜서 나온 output에 sigmoid를 통과해서 확률이 나오도록하는것</p>
<p><img src="/assets/images/image-20210205111934634.png" alt="image-20210205111934634">    </p>
<p>neural network의 weight의 차원값은 지속해서 늘어남이전입력들이 계속해서 늘어나기 때문에</p>
<ul>
<li>NADE is explicit model</li>
<li>Suppose we have 784개의 binary pixel</li>
</ul>
<p>알고있는 값들을 집어넣은뒤 계산하게 되면 확률값이 나옴</p>
<p><img src="/assets/images/image-20210205112108078.png" alt="image-20210205112108078"></p>
<p>Density estimate : 확률적으로 무언가의 확률을 explit하게 계산한다</p>
<p>Continous한 r.v를 modeling할때는 Gaussian이 사용이 된다</p>
<br/>

<h2 id="Pixel-RNN"><a href="#Pixel-RNN" class="headerlink" title="Pixel RNN"></a>Pixel RNN</h2><br/>

<ul>
<li>Use RNNs to define an auto regressive model</li>
<li>이전에 봤던 NADE는 dense layer을 사용함 하지만 Pixel RNN은 RNN을 통해 generate한다</li>
<li><img src="/assets/images/image-20210205112323136.png" alt="image-20210205112323136"><ul>
<li><p>ordering의 순서에 따라</p>
<p>Row LSTM</p>
<p>Diagonal BiLTM</p>
<p><img src="/assets/images/image-20210214141351023.png" alt="image-20210214141351023"></p>
<br/></li>
</ul>
</li>
</ul>
<br/>

<h1 id="Latent-Variable-Models"><a href="#Latent-Variable-Models" class="headerlink" title="Latent Variable Models"></a>Latent Variable Models</h1><h2 id="Variational-Auto-encoder"><a href="#Variational-Auto-encoder" class="headerlink" title="Variational Auto-encoder"></a>Variational Auto-encoder</h2><ul>
<li><p>Is an autoencoder generative model??</p>
<p>autoencoder은 input을 재정의하는 과정이지 generative model은 아니다</p>
<p>과연 무엇때문에 Variational Auto-Encoder은 generation 모델인가?</p>
</li>
<li><p>Variational inference (VI)</p>
<ul>
<li>The goal of VI is to optimize the variational distribution that best matches the <strong>posterior distribution</strong></li>
</ul>
</li>
<li><p>posterior distribution : observation이 주어졌을때 내가 관심있어하는 r.v의 확률분포</p>
<ul>
<li>posterior distribution을 계산하는건 매우 힘들기 때문에 Variational distribution을 근사한다</li>
</ul>
</li>
</ul>
<p>KL divergence를 사용해서 Variational distribution과 Posterior distribution의 차이를 줄여보겠다</p>
<p><img src="/assets/images/image-20210214142712060.png" alt="image-20210214142712060"></p>
<p><strong>How?</strong></p>
<p><img src="/assets/images/image-20210214142913172.png" alt="image-20210214142913172"></p>
<p>원해는 KL divergence를 줄이는게 목적이지만 이게 불가능하기 때문에 ELBO라고 불리는 term을 최대화 한다</p>
<br/>

<ul>
<li><p><strong>ELBO can further be decomposed into</strong></p>
<p><img src="/assets/images/image-20210214144517622.png" alt="image-20210214144517622"></p>
</li>
</ul>
<p>Reconstruction Term</p>
<p>x라는 입력을 latent space로 보냈다가 Decoder로 돌아오는 Reconstruction loss를 줄이는 term</p>
<p>Latent space에 올려놓은 점들이 이루는 분포가 Latent space의 prior distribution와 비슷하다? implicit한 model</p>
<br/>

<p>Decoder이후의 output domain의 값들이 generation result이다</p>
<p>Auto encoder은 이게 아니라 generation model이 아니다</p>
<br/>

<p>Key limitation</p>
<ul>
<li>Interactable model (hard to evaluate likelihood)</li>
<li>reconstruction term은 상관없는데 KL divergence를 사용한 prior distribution에는 무조건 미분이 가능한 distribution (like Gaussian)을 사용해야 한다. 따라서 diverse한 latent prior distributions에는 사용을 하기에 힘들다</li>
<li>In most cases, we use an isotropic Gaussian</li>
<li><img src="/assets/images/image-20210214145657271.png" alt="image-20210214145657271"></li>
</ul>
<br/>

<h2 id="Adversarial-Auto-encoder"><a href="#Adversarial-Auto-encoder" class="headerlink" title="Adversarial Auto-encoder"></a>Adversarial Auto-encoder</h2><br/>

<ul>
<li><p>It allows us to use any arbitrary latent distributions that we can sample</p>
<p><img src="/assets/images/image-20210214145814068.png" alt="image-20210214145814068"></p>
<p>Prior fitting term을 gan을 사용하여 분포를 맞추어줌</p>
<p>sampling이 가능한 어떠한 분포도 맞출수있다는 장점이 있다</p>
</li>
</ul>
<h2 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h2><p><img src="/assets/images/image-20210214151437158.png" alt="image-20210214151437158"></p>
<p>discriminator가 점차 발전해 나가면서 generator도 따라서 성능이 올라가는 상생의?</p>
<h3 id="GAN-vs-VAE"><a href="#GAN-vs-VAE" class="headerlink" title="GAN vs VAE"></a>GAN vs VAE</h3><p><img src="/assets/images/image-20210214151545975.png" alt="image-20210214151545975"></p>
<h3 id="GAN의-Objective"><a href="#GAN의-Objective" class="headerlink" title="GAN의 Objective"></a>GAN의 Objective</h3><ul>
<li><p>For discriminator<img src="assets/images/image-20210214151646421.png" alt="image-20210214151646421"></p>
<p>where the optimal discriminator is <img src="/assets/images/image-20210214151813712.png" alt="image-20210214151813712"></p>
</li>
<li><p>For generator</p>
<p><img src="/assets/images/image-20210214151923764.png" alt="image-20210214151923764"></p>
<p><strong>GAN의 objective는 나의 true generative distribution과 내가 학습하고자하는 generator사이의 Jenson-Shannon Divergence를 최소화 하는것이다</strong></p>
</li>
</ul>
<h3 id="DCGAN"><a href="#DCGAN" class="headerlink" title="DCGAN"></a>DCGAN</h3><p><img src="/assets/images/image-20210214152052429.png" alt="image-20210214152052429"></p>
<h3 id="Info-GAN"><a href="#Info-GAN" class="headerlink" title="Info-GAN"></a>Info-GAN</h3><p><img src="/assets/images/image-20210214152117180.png" alt="image-20210214152117180"></p>
<p>학습시에 class라는 random한 one-hot vector를 매번 집어 넣어준다</p>
<p>generation시에 gan이 특정모드에 집중할 수 있게끔해준다</p>
<h3 id="Text2Image"><a href="#Text2Image" class="headerlink" title="Text2Image"></a>Text2Image</h3><p><img src="/assets/images/image-20210214152233370.png" alt="image-20210214152233370"></p>
<p>텍스트로 이미지를 generate하는 연구</p>
<p>model이 매우 복잡하다…….</p>
<br/>

<p>CycleGAN</p>
<p><img src="/assets/images/image-20210214152414654.png" alt="image-20210214152414654"></p>
<p>이 cycle consistency loss가 매우 중요하다</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-02-04T15:00:00.000Z" title="2020. 2. 5. 오전 12:00:00">2020-02-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-04-21T17:35:24.595Z" title="2021. 4. 22. 오전 2:35:24">2021-04-22</time></span><span class="level-item"><a class="link-muted" href="/categories/PaperReview/">PaperReview</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/05/2021-02-05-Attention/">Paper Review) Attention Is All You Need</a></h1><div class="content"><br/>

<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>Seuence transduction model들은 현재 복잡한 recurrent한 구조 (RNN) 이나 encoder decoder를 포함한 CNN이 주를 이룬다. 가장 좋은성능을 내는 model또한 attention mechanism을 이용하여 encoder와 decoder를 연결하는 형태이다.</p>
<p>이 논문에서는 새로운 방법인 Transformer를 제안</p>
<p>이는 오로지 attention mechanism만을 사용!</p>
<p>이는 RNN이나 CNN보다 더 <strong>병렬화가 가능하고 train하는데 적은 시간이 걸린다!</strong></p>
<p>WMT 2014 English to-German data를 사용하여 BLEU라는 score에서 28.4점을 얻었다.(여러 논문을 읽다보면 자주 등장하는 이 BLUE score은 정리해 놓은게 있는데 추후에 posting )</p>
<p>이는 앙상블을 포함한 이전의 가장 좋은 성능보다 2BLUE가 높다.</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><br/>

<p>RNN모델 (LSTM이나 GRU)는 machine translation과 같은 sequence modeling의 State of the art한(최신의 가장 좋은 성능의) 접근방식으로 알려져있다. RNN은 input과 output의 위치를 계산한 결과를 담고있다. 계산하는 시간이나 순서에 의해 정렬된 위치들은 이전의 hidden state h<del>t-1</del>로 표현된 연속적인 hidden state h<del>t</del>를 생성한다. 이것은 본질적으로 training examples의 병렬화를 배제하며, 이로인해 memory의 한계로 인한 batch size의 한계 때문에 긴 sequence length에 굉장히 critical한 요소로 작용한다. 최근의 연구들은 factorization과 conditional computation(이것에 대한 논문: Oleksii Kuchaiev and Boris Ginsburg. Factorization tricks for LSTM networks, Noam Shazeer, Azalia Mirhoseini, Krzysztof Maziarz, Andy Davis, Quoc Le, Geoffrey Hinton, and Jeff Dean. Outrageously large neural networks: The sparsely-gated mixture-of-experts layer )을 이용한 계산과정의 효율화로 큰 발전을 이루어냈다. 하지만 순차적인 계산에 의한 제약은 아직 남아있다</p>
<p>Attention mechanism은 input과 out사이의 길이에 상관없이 dependencies를  modeling할수있다는 부분에서 sequence modeling과 transduction modeling의 필수적인 부분이 되었다. 하지만 몇몇 경우에서는 아직 attention mechanism과 RNN을 합쳐서 사용하고 있다.</p>
<p>이 연구에서는 Transformer라는 attention mechanism에만 의존하여 input과 output의 dependency를 이끌어내는 architecture을 제안한다. Transformer은 병렬화를 가능하게 하고, 성능을 더욱 향상시킬수 있다</p>
<br/>

<p>요약 : 우리의 transformer가 training example의 병렬화로 인한 속도 향상과 좋은 점수를 낸다.</p>
<br/>

<h2 id="2-Background"><a href="#2-Background" class="headerlink" title="2. Background"></a>2. Background</h2><p>encoder , decoder에대한 background</p>
<p>중간의 latent space는 input이나 output보다 훨씬 최소화된 vector이다. Sequential한 계산을 줄이는 목표는 기본적인 building block에서 CNN을 사용하여 병렬적으로 input과 output의 hidden representation을 계산하는 ByteNet이나 ConvS2S의 기반을 이루고있다. 위와 같은 model에서는 2개의 input이나 output의 길이가 증가할수록 계산량이 늘어난다.(ByteNet은 log적으로, ConvS2S는 linear하게). 이러한 결과는 거리에 따른 dependencies들을 학습하기에 더욱 어렵게 만든다. </p>
<br/>

<p>※ (input과 output사이의 길이가 길어지면 계산량이 증가해 서로의 연관관계를 학습하기가 어렵다는 뜻</p>
<p>cnn은 한번에 kernel size를 진짜 커봤자 최대 7x7을 쓰기 때문에 만약 input이 엄청 길다면 CNN연산시 계산량이 증가하게 되고 위치에 대한 정보의 일부만이 담기게됨. 예를 들어 간단하게 she is pretty and good at playing piano with her own piano와 같은 문장에서 뒤에 her과 처음 she는 긴 거리를 가지게 되어서 이 정보를 담기에 CNN은 부적절?).</p>
<br/>



<p>Transformer에서는 linear나 logmatric하게 계산량이 증가하지 않고 constant한 number로 증가한다.Attention-weigheted position의 <strong>평균</strong>을 사용하여  Effective한 **해상도?**가 감소함에도Multi-Head Attention과 상호작용 함으로서 계산량을 줄였다.</p>
<p>Self-attention은 서로 다른 position에 있는 sequence를 표현하기 위해 서로를 relating한다. </p>
<p>Self-attention은 reading comprehension, abstractive summarization, textual entailment and learning task-independent sentence representation과 같은 분야에서 성공적으로 사용되어져 왔다.</p>
<p>End-to-end memory network은 순서에 따라 정렬된 recurrence가 아닌 recurrent attention mechanism을 기반으로 하고있고, 좋은 성능을 보여주고 있다.</p>
<p>Transformer은 처음으로 RNN을 사용하지 않고 오로지 self-attention만이 쓰인 첫번째 변역 model이다.</p>
<br/>

<br/>

<p>요약 :  Sequence한 문제에서의 모델</p>
<p>​    RNN의 단점 : 병렬화의 어려움으로 인한 계산의 복잡도 증가, train 시간의 증가,</p>
<p>​    (그리고 강의에서 만약     sequential한 데이터중 중간에 어느 하나가빠진다면 해결하기가 어렵다고 했다)</p>
<p>​    CNN의 단점 : 병렬적인 계산은 이루어 지지만, input이나 output의 길이가 증가할수록 계산도 많고 단어간의 관    계파악이 빡셈</p>
<p>​    따라서 Attention만 쓴 Transformer 짱</p>
<p><br/><br/></p>
<h2 id="3-Model-Atchitecture"><a href="#3-Model-Atchitecture" class="headerlink" title="3. Model Atchitecture"></a>3. Model Atchitecture</h2><p>가장 경쟁력이 좋은 neural sequence transduction model은 encoder-decoder 구조를 가지고 있다. Encoder은 입력 sequence를 x = (x<del>1</del>,….x<del>n</del>)으로 표현하였고 이를 z = (z<del>1</del>,….z<del>n</del>)으로 map한다. 주어진 z로 decoder가 output sequence인 (y<del>1</del>,…,y<del>m</del>)을 생성해 낸다.(보통 중간의 latent 층은 input과 output에 비해 작은 dimension을 가진다고 조교님께서 설명) 각 step마다 model은 <strong>auto-regressive</strong>하며, 문장을 생성할때 이전에 생성된 symbol을 additional input으로 가정한다.</p>
<p><br/><br/></p>
<br/>

<p>※ Auto regressive 복습</p>
<p>(고정된 길이인 $\tau$만큼의 시퀀스만 활용하는 경우 Autoregressive Model(자기회귀모델)이라고 부른다</p>
<p>직전과거의 정보랑 직전정보가 아닌 정보들을 H<del>t</del>로 묶어서 활용)</p>
<p><img src="/assets/images/image-20210204114520892-1612513436394.png" alt="image-20210204114520892"></p>
<p><br/><br/></p>
<p><br/><br/></p>
<p>Transformer은 stacked된 self-attention을 사용하고 있고, encoder와 decoder부분에 모두 fully connected layer를 삽입하였다.</p>
<p><img src="/assets/images/image-20210205125403138.png" alt="image-20210205125403138"></p>
<br/>

<h3 id="3-1-Encoder-and-Decoder-Stacks"><a href="#3-1-Encoder-and-Decoder-Stacks" class="headerlink" title="3.1 Encoder and Decoder Stacks"></a>3.1 Encoder and Decoder Stacks</h3><p><strong>Encoder</strong> : encoder은 N=6 (6개)인 각각의 identical한 layer들이 층층이 쌓여있다. 각각의 layer들은 2개의 sub-layer로 구성되어있다. 첫번째는 Multi-Head Attention이고, 두번째는 간단한 fully-connected된 feed-forward network이다.</p>
<p>우리는 각각의 sublayer에 <strong>residual connection</strong>을 들어 주었다.</p>
<br/>

<p>※여기서 과연 residual connection을 넣은 이유가 뭘까? overfitting 방지 like ResNet??</p>
<br/>

<p>각각의 sub-layer의 output은 <em>LayerNorm(x + Sublayer(x))</em>. 모든 sublayer model과 embedding layer의 output의 차원은 d<del>model</del> = 512 이다.</p>
<br/>

<p><strong>Decoder</strong> : Decoder또한 N=6인 각각의 identical한 layer들이 층층이 쌓여있다. Encoder의 2개의 각 sub-layer에 Decoder은 <strong>encoder stack의 output에 대한 multi-Head attention</strong>을 수행하는 층이 추가가 되었다.</p>
<p>Encoder와 같이 sublayer에 residual connection을 만들어 주었다. 하위 position이 attend하는것을 방지하기 위해 self-attention-layer을 약간 수정하였다**(이게 masking). 이 masking은 i위치의 예측이 i보다 과거의 것으로만 구해지게 하기 위함이다.**</p>
<br/>

<p>※ Masking은 NLP 문제에서 굉장히 많이 쓰인다고 한다. 알아두자</p>
<br/>



<br/>

<h3 id="3-2-Attention"><a href="#3-2-Attention" class="headerlink" title="3.2 Attention"></a>3.2 Attention</h3><p>Attention function은 query와 set of key-value pair들을 output에 mapping하는 함수이다. (query,key,value,output은 모두 vector). Output은 value들의 weighted sum으로 계산하며, 이 weight는 query와 다른모든 key값들의 <strong>compatibility function</strong>으로 정해진다.</p>
<p>※여기서 compatibility function이란?</p>
<p>뒤에서 sum의 형태와 dot product로 나누어 진다. 이들의 차이점은 뒤에 기술</p>
<p><img src="/assets/images/image-20210205131926013.png" alt="image-20210205131926013"></p>
<br/>

<h4 id="3-2-1-Scaled-Dot-Product-Attention"><a href="#3-2-1-Scaled-Dot-Product-Attention" class="headerlink" title="3.2.1 Scaled Dot-Product Attention"></a>3.2.1 Scaled Dot-Product Attention</h4><p>우리는 이러한 attention을 “Scaled Dot-Product Attention”이라고 부른다. Input은 d<del>k</del>의 차원을 가지는 keys와 queries(둘은 연산(내적)을 위해 같은 차원을 가진다)와  d<del>v</del>의 차원을 가지는 values로 이루어져 있다. 우리는 하나의 query 를 다은 모든 keys들과 내적하고(이 결과 값이 바로 강의에서 score) sqrt(d<del>k</del>)로 나누어 준다. 이후 softmax function을 적용하여 value의 weight를 얻어낸다.</p>
<p>※ i번째 단어에 대한 score vector 계산시 i의 쿼리 vector와 다른모든 key vectors 사이의 내적 (Matmul)</p>
<p>위의 과정들을 queries들을 Q matrix, keys and values를 각각 K and V라고 한다면 아래의 식으로 표현가능</p>
<p><img src="/assets/images/image-20210205132622631.png" alt="image-20210205132622631"></p>
<p>가장 많이쓰는 attention function의 함수는 additive attention과 위와 같은 dot-product attention이다. 우리는 dot-product attention을 썼다. </p>
<p>Additive attention은 하나의 hidden layer와 feed forward network를 사용하여compatibility function을 계산한다. 이두가지는 복잡도 측면에서 비슷하지만, dot-product attention이 더빠르고 공간 절약적이다.(이유는 행렬의 계산으로 표현가능)</p>
<p>작은 값을 가지는 d<del>k</del>에서의  두 mechanism은 유사하겠지만, 큰 d<del>k</del>로 나누어 주지 않으면 additive attention이 dot-product의 성능을 넘는다. 큰  d<del>k</del>는  dot -product는 큰값을 가지게 되고, 이는 softmax function이 매우 작은 gradient를 가지게 한다. 이러한 영향을 줄이기 위해 sqrt(d<del>k</del>)로 나누어 주었다. (scale)</p>
<br/>

<h4 id="3-2-2-Multi-Head-Attention"><a href="#3-2-2-Multi-Head-Attention" class="headerlink" title="3.2.2 Multi-Head Attention"></a>3.2.2 Multi-Head Attention</h4><p>d<del>model</del>(max sequence)의 차원을 가지는 keys,values,queries으로 이루어진 single attention을 수행하는것이 아니라, 우리는 queries, keys, values들에 각각 h번 d<del>k</del>,d<del>k</del>,d<del>v</del>를 곱하여 project한값이 더욱 좋은것을 알아내었다.</p>
<p>이러한 <strong>projection</strong>을 거치면 attention function을 병렬적으로 수행 할 수있으며, d<del>v</del>의 차원을 가지는 output을 얻어낼 수 있다. 이 output은 다시 하나로 concatnated되어 projected된다.</p>
<p><img src="/assets/images/image-20210205134008271.png" alt="image-20210205134008271"></p>
<p>Multi-Head Attention은 서로다른 위치에서의 서로다른 subspace의 표현을 jointly attend 하게 한다.</p>
<p><img src="/assets/images/image-20210205134243929.png" alt="image-20210205134243929"></p>
<p>우리는 h = 8개의 parallel attention layer을 사용하였고,d<del>k</del>,d<del>v</del>,d<del>model</del>/h = 64</p>
<p><strong>각각의 head에서 차원을 줄임으로서 전체적인 계싼비용이 single head attention과 비슷하게 만들었다???????</strong></p>
<p>※ 한마디로 이제 d<del>model</del>의 차원을 h만큼 parrel layer에 나누어서 넣었으니 결국 single head attention과 비슷하다는 이야기인가??</p>
<br/>

<h4 id="3-2-3-Applications-of-Attention-in-our-Model"><a href="#3-2-3-Applications-of-Attention-in-our-Model" class="headerlink" title="3.2.3 Applications of Attention in our Model"></a>3.2.3 Applications of Attention in our Model</h4><p>Transformer은 multi-head attention을 3가지 다른 방식으로 사용하고 있다</p>
<ol>
<li><p>“Encoder - Decoder attention” layer에서 queries는 이전의 decoder layer에서 오고, encoder의 output에서 오는 key와 value들을 저장한다. 이것은 input sequence의 모든 position들을 모든 position의 decoder가 attend 하게 해준다.</p>
<p>한마디로 decoder을 쿼리만 들고있어도 된다.</p>
<br/></li>
<li><p>Self attention layer를 포함하는 encoder. Self attention layer에서는 이전 encoder의 layer의 결과에서부터 나온 위치와 같은 위치에서  모든 key, values, and queries가 나온다. encoder속의 각각의 위치들은  이전 encoder의 이전 layer의 모든 위치에 집중한다. (모든 현재 layer의 위치가 이전 layer의 모든 position 정보들을 가진다? 이런느낌?)</p>
<br/></li>
<li><p>비슷하게 decoder의 self attention layer또한 모든  decoder안의 모든(자기자신까지) position에 집중한다.<strong>Auto regressive 특성을 보존시키기 위해 왼쪽의 정보들이 decoder로 flow in 하는걸 막아주어야 한다. 우리는 이러한 걸 scaled dot product attention안의 softmax의 output 값에masking out함으로서 해결한다</strong></p>
<p>이걸 다시한번 생각해 보아야 겠다</p>
<p>Auto regressive한 특성이란 이전의 정보들 만으로 현재값을 도출해내는 특성</p>
<p>그니까 결국은 위에(1)식에서 softmax의 결과값에 미래의 정보들은 모두 masking 해준다는것이다.</p>
<p>그니까 결국엔 <img src="/assets/images/image-20210205132622631-1612515516800.png" alt="image-20210205132622631"> </p>
<p>이식에서 미래의 정보들까지 K와 Q의 내적결과가 다담고 있으니까 미래의 정보는 마스킹 해준다.</p>
<br/></li>
</ol>
<h3 id="3-3-Position-wise-Feed-Forward-Networks"><a href="#3-3-Position-wise-Feed-Forward-Networks" class="headerlink" title="3.3 Position-wise Feed Forward Networks"></a>3.3 Position-wise Feed Forward Networks</h3><p>encoder와 decoder안의 각 layer에는 fully connected feed forward network를 가져야 한다.  이 <strong>fully connected feed forward network는 각각의 위치에 독립적으로 따로 적용된다</strong></p>
<p><img src="/assets/images/image-20210205155145255.png" alt="image-20210205155145255"></p>
<p>위식을 보면 2개의 linear transformation과 ReLU activation을 그사이에 사용하였다.</p>
<p><strong>Linear transformation을 각각의 position에 같은 걸 적용해야 한다. 그리고 layer과 layer사이에는 다른 parameter를 적용해야 한다. 또다른 방법은 1의 kernel size를 가지는 2개의 convoltion을 사용하는 것이다.</strong></p>
<p>※ 그니까 하나의 layer에는 같은 weight를 적용하고 다른 layer사이에는 다른 weight를 적용한다는 뜻???</p>
<br/>

<p>d<del>model</del> = 512</p>
<p>inner-layer’s dimension d<del>ff</del> = 2048</p>
<br/>

<h3 id="3-4-Embedding-and-Softmax"><a href="#3-4-Embedding-and-Softmax" class="headerlink" title="3.4 Embedding and Softmax"></a>3.4 Embedding and Softmax</h3><p>여타 다른 번역 모델과 같이 여기서도 학습된 embadding을 사용했다.</p>
<p>Decode되어 나온결과도 학습된 linear transformation과 softmax함수를 사용하여 다음 token의 확률을 계산하였다.</p>
<p>embedding layer들에는 같은 weight와 presoftmax linear transformation을 사용, weight의 결과에 sqrt(d<del>model</del>)을 사용했다.</p>
<br/>

<h3 id="3-5-Positional-Encoding"><a href="#3-5-Positional-Encoding" class="headerlink" title="3.5 Positional Encoding"></a>3.5 Positional Encoding</h3><p>우리의 model은 recurrence도 없고 convolution도 없어서 각각의 model이 sequence의 순서를 사용하게 하여면 position 정보를 삽입해 주어야 한다.</p>
<p>따라서 </p>
<p><img src="/assets/images/image-20210205094724396-1612516229839.png" alt="image-20210205094724396"></p>
<p>이와 같이 각각 embedding된 vector에 positional encoding된 vector를 더해준다</p>
<p>이 연구에서는 cos과 sin 함수를 사용했다</p>
<p><img src="/assets/images/image-20210205181144831.png" alt="image-20210205181144831"></p>
<p>pos 는 position i는 차원</p>
<p>각각의 위치가 sinusodial하게 encoding 되도혹 하였다. 주기가 조올라 길어서 다른위친데 주기성 때문에 같은 값을 가지는 경우는 드물다</p>
<br/>

<h2 id="4-Why-Self-Attention"><a href="#4-Why-Self-Attention" class="headerlink" title="4. Why Self-Attention"></a>4. Why Self-Attention</h2><p>이 부분에서는 self attention layer를 RNN과 CNN에 더욱 자세히 비교한다.</p>
<p>앞에서 설명한거에 대한 보충설명</p>
<ol>
<li><p>한 layer에서 계산 복잡도에서의 이득</p>
</li>
<li><p>병렬화 될 수 있는계산의 총량</p>
</li>
<li><p>길이가 기이이일어졌을때 얼마나 network에 영향을 미치는지</p>
<p>길이가 졸라리 길어졌을때 dependencies는 매우 중요하다. 이에 가장 중요하게 미치는 영향중 하나가 signal하나가 network를 순회하는 길이이다?? 이게 짧아질수록 긴 길이에 대한 상호적인 관계가 더 잘 학습된다. 따라서 각 model마다 model에서 input과 output 사이의 거리? 뭐하이튼 그 얼마나 model이 compact한가</p>
</li>
</ol>
<p><img src="/assets/images/image-20210205181818372.png" alt="image-20210205181818372"></p>
<p>위 table을 보면 computational한 성능을 높이기 위해 self attention 모델은 해당하는 output 위치의 오직 size r 만큼의 input sequence 주위를 고려하도록 제한되어있다.</p>
<p>이거에 대한 연구는 추후에 발표하겠다고 적혀있다. 그럼 이미 나와있겠지?</p>
<p>하이튼 위에꺼 비교해보면 모든 측면에서 self attention이 와따</p>
<br/>

<h2 id="5-Training"><a href="#5-Training" class="headerlink" title="5. Training"></a>5. Training</h2><h3 id="1-Training-data-and-batching"><a href="#1-Training-data-and-batching" class="headerlink" title="1. Training data and batching"></a>1. Training data and batching</h3><p>WMT 2014를 사용하여 train함</p>
<p>그리고 문장은 target vocab와 37000개를 공유하는 byte-pair encoding이라는 방식을 사용했음</p>
<p>각 traning batch는 25000개의 source token과 25000개의 target token을 포함하는 문장의 set으로 정해주었다.</p>
<h3 id="2-Optimizer"><a href="#2-Optimizer" class="headerlink" title="2. Optimizer"></a>2. Optimizer</h3><p>Adam을 썼고, lr을 단계적으로 변화시켰다.아래와 같은 수식으로</p>
<p><img src="/assets/images/image-20210205182950061.png" alt="image-20210205182950061"></p>
<br/>

<h3 id="3-Regularization"><a href="#3-Regularization" class="headerlink" title="3. Regularization"></a>3. Regularization</h3><ol>
<li><p>Residual Dropout</p>
<p>더해지고 normalized 되기전에 각각의 sublayer의 output에 dropout을 적용하였다</p>
<p>그리고 또 embedding된 vector와 position의 합이후에도 적용하였다</p>
<p>P<del>drop</del>은 0.1 </p>
</li>
<li><p>Label Smoothing???</p>
<p>이런걸 적용했다고 하느네 이게 약간 예측불가능한걸 더해줘서 model이 더 새로운것을 배우게끔하는 거라하는데 걍 간단하게 나와있다</p>
<br/></li>
</ol>
<h2 id="6-Results"><a href="#6-Results" class="headerlink" title="6. Results"></a>6. Results</h2><p>BLEU score 잘나왔다 어쩌구 저쩌구 하다가</p>
<p>base model에서는 5개의 checkpoint를 만들어서 그것의 평균을 낸 하나의 model을 썼고, 각 check point는 10분마다 한번씩 interval을 주었다.</p>
<p>이게 내가 조교님한테 질문했던 부분과 좀 연관성이 있다. 이렇게 중간중간에 model을 기록하고 평균을 내는 방식도 있구나</p>
<p>그리고 이 beam search를 사용하였다고 한다</p>
<p>이건 이전의 논문들을 읽을때도 자주 사용했던 기법이다</p>
<p>간단하게 설명하면 가장 확률이 높은 K개을 선택하며 진행하는 것이다</p>
<p>greedy방법보다 효율적이고 score가 잘나온다고 들었다</p>
<h3 id="6-2-Model-Variations"><a href="#6-2-Model-Variations" class="headerlink" title="6.2 Model Variations"></a>6.2 Model Variations</h3><p>아래 table의 (A)를 보면 attention의 head의 개수와 key,value의 dimension을 변화시켜주었다. 너무 많은 head를 사용해도 안되고 하나만 사용해도 안됨</p>
<p>이건 너무 당연한거다 뭐든지 적당한게 좋다</p>
<p><img src="/assets/images/image-20210205184119740.png" alt="image-20210205184119740"></p>
<h3 id="6-3-English-Constituency-Parsing"><a href="#6-3-English-Constituency-Parsing" class="headerlink" title="6.3 English Constituency Parsing"></a>6.3 English Constituency Parsing</h3><p>이 Transformer를 활용한 model은 통역에서 나아가서 영어 구문을 분석해주는 방법으로 발전시켜나가야 한다. </p>
<p>이건 별로 중요하지 않은것 같다</p>
<p>해보니까 RNN보다 좋은 성능을 나타내었다 끝</p>
<h2 id="7-Conclusion"><a href="#7-Conclusion" class="headerlink" title="7. Conclusion"></a>7. Conclusion</h2><p>결론 </p>
<p>기존과 다르게 attention에만 기반을 둔 multi-headed self attention을 사용한 이 transformer은 다른 RNN이나 CNN보다 성능이 빠르며 이 Transfomer를 더욱큰 input과 output을 가지는 image나 비디오 오디오 등에적용시키는 것을 기대하고 있다.</p>
<p>Transformer 짱짱맨</p>
<p>그리고 조교님께서 관심 있으신 Neuroscience와 Attention사이의 관련</p>
<p><img src="/assets/images/image-20210205185431936.png" alt="image-20210205185431936"></p>
<p>보면 우리 인간의 황반에서도 이 attention의 개념을 적용해서 사물을 인지하고 있으니, 잘되는게 어찌보면 당연하다</p>
<p>출처 : <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1706.03762.pdf">https://arxiv.org/pdf/1706.03762.pdf</a></p>
<p>그리고 naver boostcamp</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-02-03T15:00:00.000Z" title="2020. 2. 4. 오전 12:00:00">2020-02-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-04-21T17:35:11.019Z" title="2021. 4. 22. 오전 2:35:11">2021-04-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Boostcamp/">Boostcamp</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/04/2021-02-04-Boostcamp14.1/">Day14) RNN1</a></h1><div class="content"><p><br/><br/></p>
<h1 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h1><hr>
<br/>

<h2 id="Sequence-Data-amp-Model"><a href="#Sequence-Data-amp-Model" class="headerlink" title="Sequence Data &amp; Model"></a>Sequence Data &amp; Model</h2><br/>

<ul>
<li><p>소리, 주가, 문자열 등의 데이터를 시퀀스 데이터로 분휴합니다</p>
</li>
<li><p>시계열 데이터는 시간순서에 따라 나열된 데이터로 시퀀스 데이터에 속한다</p>
</li>
<li><p>독립동등분포 가정을 잘 위해하기 때문에 순서를 바꾸거나 과거정보에 손실이 발생하면 데이터의 확률분포도 바뀌게 된다</p>
</li>
<li><p>Markov model : first order autoregressive model</p>
</li>
<li><p>이들의 문제를 해결하기 위해 Latent autoregressive model</p>
<p>hidden state가 과거의 정보들을 summerize한다</p>
</li>
</ul>
<h3 id="다루는-법"><a href="#다루는-법" class="headerlink" title="다루는 법"></a>다루는 법</h3><ul>
<li>조건부 확률을 이용(과의 정보를 가지고 미래를 예측 )</li>
</ul>
<p><img src="/assets/images/image-20210204112231880.png" alt="image-20210204112231880"></p>
<p>바로직전까지의 정보 S-1를 사용해서 현재인 S를 업데이트</p>
<p>반드시 모든 과거의 정보를 가지고 업데이트 하는 것은 아니다</p>
<p>따라서 조건부에 들어가는 데이터의 길이는 <strong>가변적이다</strong></p>
<br/>

<p>고정된 길이인 $\tau$만큼의 시퀀스만 활용하는 경우 Autoregressive Model(자기회귀모델)이라고 부른다</p>
<p>직전과거의 정보랑 직전정보가 아닌 정보들을 H<del>t</del>로 묶어서 활용</p>
<p><img src="/assets/images/image-20210204114520892.png" alt="image-20210204114520892"></p>
<p>길이가 가변적이지 않고 이제 고정되기 때문에 여러가지 장점을 가지고 있다</p>
<p>사실은 과거의 모든 정보를 고려하기가 힘든 문제점을 고쳐서 이제 이전의 정보를 요약하는H<del>t</del>를 예측하는 모델 —-&gt; RNN</p>
<p><br/><img src="/assets/images/image-20210204132225632.png" alt="image-20210204132225632"></p>
<h2 id="RNN-이해하기"><a href="#RNN-이해하기" class="headerlink" title="RNN 이해하기"></a>RNN 이해하기</h2><ul>
<li><p>기본적인 모형은 MLP와 유사하다</p>
</li>
<li><p><img src="assets/images/image-20210204115917697.png" alt="image-20210204115917697"></p>
</li>
<li><p>RNN의 역전파는 잠재변수의 연결그래프에 따라 순차적으로 계산한다</p>
<p>Back Propagation Through Time</p>
</li>
</ul>
<h3 id="BTTP를-살펴봅시다"><a href="#BTTP를-살펴봅시다" class="headerlink" title="BTTP를 살펴봅시다"></a>BTTP를 살펴봅시다</h3><p>BTTP를 통해 gradient를 계산해보면 미분의 곱으로 이루어진 항이 계산이 된다</p>
<p><img src="/assets/images/image-20210204123130405.png" alt="image-20210204123130405"></p>
<p>길어지면 계산이 불안정해짐으로(gradient vanishing과 같은)문제가 있기 때문에</p>
<p>길이를 끊는것으로 truncated BPTT</p>
<br/>

<h3 id="Gradient-vanishing-문제의-해결"><a href="#Gradient-vanishing-문제의-해결" class="headerlink" title="Gradient vanishing 문제의 해결??"></a>Gradient vanishing 문제의 해결??</h3><ul>
<li>시퀀스 길이가 길어지는 경우에는 BTTP를 통한 역전파 알고리즘의 계산이 불안정해 지므로 길이를 끊는것이 중요하다</li>
<li>ex) LSTM, GRU …..</li>
</ul>
<p><img src="/assets/images/image-20210204132428721.png" alt="image-20210204132428721"></p>
<p>RNN을 시간순으로 쭉 풀면 결국 fully connected layer network가 된다</p>
<p>가장어려운 ? 단점 ? —-&gt; 하나의 fixed rule로 이전의 정보들을 summerize하기 때문에 먼 과거의 정보들이 현재에서 살아남기가 힘들다!! 이게 short term dependencies</p>
<p><img src="/assets/images/image-20210204132956315.png" alt="image-20210204132956315"></p>
<p>결국 먼 과거의 정보들은 많은 양의 activation function과 W곱의 결과로 vanishing or exploding되는 현상이 일어나게 된다</p>
<br/>

<br/>

<h2 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h2><p><img src="/assets/images/image-20210204133224090.png" alt="image-20210204133224090"></p>
<p>LSTM의 전체적인 구조 </p>
<p><img src="/assets/images/image-20210204133348991.png" alt="image-20210204133348991"></p>
<p>들어오는 입력이 3개 나가는게 3개</p>
<p>실제로 나가는건 h<del>t</del> (hidden state)</p>
<p><img src="assets/images/image-20210205094139431-1612486098130.png" alt="image-20210205094139431"></p>
<p><img src="assets/images/image-20210205094150152-1612486110711.png" alt="image-20210205094150152"></p>
<p><img src="assets/images/image-20210205094207767-1612486121259.png" alt="image-20210205094207767"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-02-03T15:00:00.000Z" title="2020. 2. 4. 오전 12:00:00">2020-02-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-04-21T17:35:17.925Z" title="2021. 4. 22. 오전 2:35:17">2021-04-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Boostcamp/">Boostcamp</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/04/2021-02-04-Boostcamp14.2/">Day14) RNN2</a></h1><div class="content"><p><br/><br/></p>
<h1 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h1><br/>

<h2 id="Sequential-Model"><a href="#Sequential-Model" class="headerlink" title="Sequential Model"></a>Sequential Model</h2><br/>

<p><img src="/assets/images/image-20210204173823314.png" alt="image-20210204173823314"></p>
<p>위와 같은 문제로, RNN같이 sequential한 문제들을 해결할 때, 중간에 단어가 빠지거나 하면 해결하기가 어려움</p>
<p>—&gt; 여기서 나온게 Attention을 사용한 Transformer</p>
<br/>

<h2 id="Transformer-1"><a href="#Transformer-1" class="headerlink" title="Transformer"></a>Transformer</h2><br/>

<ul>
<li>Transformer is the first sequence transduction model based entirely on attention</li>
<li>RNN처럼 재귀적인게 아니라 based on attention</li>
</ul>
<p><img src="/assets/images/image-20210204174108604.png" alt="image-20210204174108604"></p>
<ul>
<li>from a bird’s-eye view, this is what the Transformer does for machine translation tasks</li>
</ul>
<p><img src="/assets/images/image-20210204185901783.png" alt="image-20210204185901783"></p>
<p>결국은 sequence to sequnece (불어 -&gt; 영어 )machine translation</p>
<p>입출력 sequence 는 숫자가 다를수 있다</p>
<p><img src="/assets/images/image-20210204185951005.png" alt="image-20210204185951005"></p>
<p>모델은 하나임. 100개가 들어가도 100번 재귀적으로 들어가는게아니라 한번에 n개를 처리</p>
<p>generation할때는 1단어씩 만들게 된다</p>
<p>동일한구조를 가지지만 공유하지 않는 encoder와 decoder가 stack되어있다</p>
<p>encoder가 바뀔수 있는 n개의 단어를 어떻게 처리하는지</p>
<p>1개의 encoder에 n개의 단어가 한번에 들어간다</p>
<p>self attention + Feed Forward Neural Network -&gt;next encoder</p>
<p>Self- Attention is the cornerstone of Transformer</p>
<h2 id="Transformer-2"><a href="#Transformer-2" class="headerlink" title="Transformer"></a>Transformer</h2><p><img src="/assets/images/image-20210205094243692.png" alt="image-20210205094243692"></p>
<p><img src="/assets/images/image-20210205094305510.png" alt="image-20210205094305510"></p>
<p><img src="/assets/images/image-20210205094323449.png" alt="image-20210205094323449"></p>
<p><img src="/assets/images/image-20210205094338045.png" alt="image-20210205094338045"></p>
<p><img src="/assets/images/image-20210205094354596.png" alt="image-20210205094354596"></p>
<p><img src="/assets/images/image-20210205094421353.png" alt="image-20210205094421353"></p>
<p><img src="/assets/images/image-20210205094434034.png" alt="image-20210205094434034"></p>
<p><img src="/assets/images/image-20210205094446386.png" alt="image-20210205094446386"></p>
<p><img src="/assets/images/image-20210205094508533.png" alt="image-20210205094508533"></p>
<p><img src="/assets/images/image-20210205094524834.png" alt="image-20210205094524834"></p>
<p><img src="/assets/images/image-20210205094724396.png" alt="image-20210205094724396"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-02-02T15:00:00.000Z" title="2020. 2. 3. 오전 12:00:00">2020-02-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-04-21T17:35:03.109Z" title="2021. 4. 22. 오전 2:35:03">2021-04-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Boostcamp/">Boostcamp</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/03/2021-02-03-Boostcamp13.2/">D13) 딥러닝기초</a></h1><div class="content"><br/>

<h1 id="Computer-Vision-application"><a href="#Computer-Vision-application" class="headerlink" title="Computer Vision application"></a>Computer Vision application</h1><br/>

<h2 id="Fully-Convolutional-Network"><a href="#Fully-Convolutional-Network" class="headerlink" title="Fully Convolutional Network"></a>Fully Convolutional Network</h2><ul>
<li>기존의 CNN 구조 : <img src="assets/images/image-20210203184815070-1612348862409.png" alt="image-20210203184815070"></li>
<li>Fully Convolutional Network : <img src="assets/images/image-20210203184859006.png" alt="image-20210203184859006"></li>
</ul>
<p>Dense layer를 없앴다. - &gt; convolutionize</p>
<p>결국 input과 output은 같다</p>
<p>parameter도 같다</p>
<p>flat을 해서 dense layer를 거치나, convolution을 거치나 같다</p>
<p>ex) 4x4x16  이 였다면 이걸 256개의 vector로 flatten 시킨다</p>
<p>​      FCN을 보면 4x4x16에 똑같은 크기를 가진 kernel을 적용한다</p>
<p>parameter </p>
<p>4x4x16x10 = 2560</p>
<p>4x4x16x10 = 2560</p>
<p>같다</p>
<p><img src="assets/images/image-20210203185349968-1612348862411.png" alt="image-20210203185349968"></p>
<p>이런짓이 convolutionization</p>
<p><strong>왜 이런걸 할까????</strong></p>
<p>image segmentation 관점에서 생각을 해보자</p>
<ul>
<li><p>Fully convolutional network가 가지는 가자은 특징은 바로 input dimension, 특히나 input dimension의 spacial dimension이다</p>
</li>
<li><p>Transforming fully connected layer into convolutional layers enables a classification to output a hitmap</p>
</li>
<li><p>output이 커지게 되면 이거에 비례해서 뒷단의 spacial dimension이 커지게 됨</p>
<p>Because of convolution이 가지는 shared parameter의 성질 때문에</p>
</li>
<li><p>원래는 출력의 hitmap은 input보다 크기가 줄어들기는 하다</p>
<p>그렇지만 hitmap이라는 가능성이 생겼구나!!!</p>
</li>
<li><p>그래서 어떠한 inputsize에도 돌아가지만 이러한 작아진 output을 <strong>다시 input size만큼 늘리는 방법</strong></p>
</li>
</ul>
<ol>
<li><strong>Deconvolution(convolution transpose)</strong></li>
</ol>
<p>간단하게 생각하면 convolution 연산으로 줄어든 결과를 convolution의 역연산으로 다시 늘려주는</p>
<p>근데 convolution의 역연산이 존재하나? 불가능하다</p>
<p>근데 그냥 간단하게 이렇게 생각하는게 편하다</p>
<p>deconvolution은 결국 convolution이후에 결과에 padding을 많이 줘서 여기에 같은 size에 kernel을 적용하는것이다</p>
<br/>

<h2 id="Dectection"><a href="#Dectection" class="headerlink" title="Dectection"></a>Dectection</h2><br/>

<h3 id="R-CNN"><a href="#R-CNN" class="headerlink" title="R-CNN"></a>R-CNN</h3><ol>
<li>takes and input image</li>
<li>extract around 2000 region proposal (using selective search)</li>
<li>computes features for each proposal (size는 모두 똑같이 맞추어 준다, use AlexNet)</li>
<li>classifies with linear SVMs</li>
</ol>
<h3 id="SPPNet"><a href="#SPPNet" class="headerlink" title="SPPNet"></a>SPPNet</h3><ul>
<li>RCNN의 문제 : 2000개를 뽑으면 2000개를 전부 CNN에 돌려야 되기 때문에 시간이 졸라 많이 걸린다</li>
<li>따라서 일단 image 안에서 bounding box를 뽑고 image 전체를 CNN에 돌리고, 해당하는 위치의 tensor만을 활용하자</li>
</ul>
<br/>

<h3 id="Fast-R-CNN"><a href="#Fast-R-CNN" class="headerlink" title="Fast R-CNN"></a>Fast R-CNN</h3><p><img src="assets/images/image-20210203192314454-1612348862411.png" alt="image-20210203192314454"></p>
<p> selective search로 bounding box를 얻고 전체 이미지를 CNN에 통과 그리고 ROI pooling layer를 통해 각각의 region에 대해서 feature를 뽑는다</p>
<p>그리고 마지막에  Fully connected layer을 통해 bounding box를 어떻게 움직이면좋은지, label이 뭔지를 알아낸다</p>
<br/>

<h3 id="Faster-R-CNN"><a href="#Faster-R-CNN" class="headerlink" title="Faster R-CNN"></a>Faster R-CNN</h3><br/>

<p>Bounding box를 뽑아내는 Region proposal도 학습을 하자!</p>
<p>selective search를 하지말고 이것도 학습을 하자는 의미</p>
<p>이 network를 region proposal Network가 추가됨</p>
<p><strong>Region proposal Network</strong></p>
<ul>
<li>이미지의 특정영역이 bounding box로서 의미가 있는지 없는지만 찾아주는 Network</li>
<li>여기서 필요한게 Anchor box</li>
<li>미리 정해놓은 Bounding box의 크기 : anchor box</li>
</ul>
<p>어떤 크기의 물체가 있을것 같다?</p>
<p>해당하는 영역의 이미지에 물체가 들어있을지 안들어있을지가 </p>
<p><img src="/assets/images/image-20210203195347275.png" alt="image-20210203195347275"></p>
<p>해당하는 영역에 물체가있을지에 대한 정보를 알고있다</p>
<p>9개의 region size중에 1개를 골라서</p>
<p>얼마나 bounding box를 늘이거나 줄일지 , xy에 off set을 줘야 해서 4개의 parameter</p>
<p>해당 box가 쓸만한지 아닌지</p>
<p>9x(4+2) = 54만큼의 channel이 나오는</p>
<br/>

<h2 id="YOLO"><a href="#YOLO" class="headerlink" title="YOLO"></a>YOLO</h2><br/>

<p>faster R-CNN보다 훨씬 빠름</p>
<p>Region에 해당하는 sub tensor을 분류하는게 아니라 그냥 image를 때려 넣으면 딱 나오기 떄문에 빠름</p>
<ul>
<li>no exclusive bounding box sampling (region proposal)</li>
</ul>
<p>YOLO에 대해서는 추가로 정리해서 따로 posting 하겠다</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-01-31T15:00:00.000Z" title="2020. 2. 1. 오전 12:00:00">2020-02-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-04-21T17:34:49.827Z" title="2021. 4. 22. 오전 2:34:49">2021-04-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Boostcamp/">Boostcamp</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/01/2021-02-01-Boostcamp11/">D11) 딥러닝기초</a></h1><div class="content"><br/>

<h1 id="베이즈-통계학"><a href="#베이즈-통계학" class="headerlink" title="베이즈 통계학"></a>베이즈 통계학</h1><ul>
<li>데이터가 추가되었을때 쓰는 인과관계에 대한 추론법</li>
</ul>
<h2 id="조건부-확률"><a href="#조건부-확률" class="headerlink" title="조건부 확률"></a>조건부 확률</h2><br/>

<ul>
<li>베이즈 정리는 곧 조건부 확률을 이용하여 정보를 갱신하는 방법을 알려줍니다</li>
</ul>
<p><img src="/assets/images/image-20210201112623410.png" alt="image-20210201112623410"></p>
<p>결국 우리가 알고 싶은 것은 A라는 새로운 추가적인 정보가 들어왔을때 P(B)로 부터 P(B l A)를 계산하는 방법을 제공한다</p>
<br/>

<h2 id="실제로-그럼-어디에-쓸까"><a href="#실제로-그럼-어디에-쓸까" class="headerlink" title="실제로 그럼 어디에 쓸까"></a>실제로 그럼 어디에 쓸까</h2><p><img src="/assets/images/image-20210201113042309.png" alt="image-20210201113042309"></p>
<ul>
<li>D : data , $\theta$ : 모수</li>
<li>사후확률 : 데이터가 주어져 있을때  $\theta$에 대한 확률</li>
<li>사전확률 : 데이터가 없는 상황에서 사전에 주어진  $\theta$ 에 대한 확률</li>
<li>Likelihood : 현재 주어진 모수에서 어떠한 Data가 관찰될 확률</li>
<li>Evidence : Data 자체의 분포</li>
</ul>
<br/>

<p>ex) COVID의 발병률이 10%로 알려져 있을 때, 이 바이러스에 실제로 <strong>걸렸을때</strong>(조건부) 검진될 확률 : 99%, 오검진 확률 : 1%</p>
<p>이 때, 어떤 사람이 양성판정일때 정말로 이사람이 바이러스에 감였되었을 확률</p>
<br/>

<p>발병률 : 사전확률</p>
<p>실제로 걸렸을 확률 :  $\theta$ </p>
<p>검진된 경우 : D</p>
<p>실제로 걸렸을 때 검진될 확률 : P(D l $\theta$) : Likelihood</p>
<p>가능도와 사전확률이 주어져 있으므로, 사후확률 계산가능</p>
<p>그렇다면 Evidence의 계산법은????????</p>
<p><img src="/assets/images/image-20210201120929030.png" alt="image-20210201120929030"></p>
<p>따라서  $\theta$를 부정했을때의 likelihood도 알아야 계산이 가능하다</p>
<h2 id="조건부-확률의-시각화"><a href="#조건부-확률의-시각화" class="headerlink" title="조건부 확률의 시각화"></a>조건부 확률의 시각화</h2><p> <img src="/assets/images/image-20210201121230522.png" alt="image-20210201121230522"></p>
<p>데이터의 성격에 따라 1종오류을 줄이냐 2종오류를 줄이냐가 달라진다</p>
<p>Ex) 의료문제의 경우 False Negative : 질병이 아니다라고 했는데 실제로 질병일 경우 따라서 False Negative에 신경을 쓴다</p>
<br/>



<p>사전 확률 : 질병에 걸릴 확률, 안걸릴 확률</p>
<p>민감도 : 걸린걸 걸렸다고 탐지</p>
<p>실제로 걸렸을 때 걸렸다고 할 확률 : 민감도</p>
<p>실제로 걸리지 않았을때 걸렸다고 할 확률 : 오탐</p>
<p>양성이 나왔을때  진짜 양성인 경우 : True Positive </p>
<p>음성이 나왔을때 진짜 음성인 경우 : True Negative</p>
<p>양성이 나왔을때 음성인 경우 : 1종 오류</p>
<p>음성이 나왔는데 질병에 걸린 경우 : 2종 오류</p>
<p>정밀도 : TP/(TP+FP)</p>
<br/>

<h2 id="베이즈-정리를-통한-정보의-갱신"><a href="#베이즈-정리를-통한-정보의-갱신" class="headerlink" title="베이즈 정리를 통한 정보의 갱신"></a>베이즈 정리를 통한 정보의 갱신</h2><ul>
<li>베이즈 정리를 통해 새로운 데이터가 들어왔을 경우 앞서 계산한 사후확률을 사전확률로 사용하여 갱신된 사후확률을 계산가능</li>
<li>앞서 양성 판정을 받은 사람이 2번째 검진을 받았을 때도 양성이 나왔을때 진짜 COVID에 걸렸을 확률은?&gt;??????</li>
</ul>
<p>베이즈 정리를 활용하여 사후확률을 연속으로 계산해보면 정밀도가 화아아악 올라간다</p>
<p>이게 바로 베이즈 정리의 강점!!</p>
<br/>

<ul>
<li><strong>BUT!!! 조건부확률로 인과관계를 추론해서는 안된다!!!!!!!!!!!</strong></li>
<li>인과 관계는 데이터 분포의 변화에 강건한 예측모형을 만들 때 고려해 주어야 한다</li>
<li>인과 관계를 고려했을 시에 예측도는 떨어질 수 있음</li>
<li>인과 관계를 알아내기 위해서는 중첩요인(confounding factor)의 효과를 제거하고 원인에 해당하는 변수만의 인과관계를 계산해야 한다</li>
<li><img src="/assets/images/image-20210201125109622.png" alt="image-20210201125109622"></li>
</ul>
<p>ex) 키와 지능 -&gt; 여기에 나이에 따른 효과를 제거하지 않는다면 키가 클수록 지능이 높다라는 결과가 나오게 됨</p>
<p>이러한 나이와 같은 중첩요인을 제거하는 것이 Main Point</p>
<br/>

<p>Ex)</p>
<p><img src="/assets/images/image-20210201125438048.png" alt="image-20210201125438048"></p>
<p>위의 문제가 바로 아주 유명한 simpsons 역설</p>
<p>a와b의 중첩효과를 제거해야 됨</p>
<p>Z의 개입을 제거하기 위해 조정(intervention)효과를 사용한다???</p>
<p>조정효과에 대한 개념이 조금 필요할듯 싶다</p>
<h1 id="Deep-Learning-Historical-Review"><a href="#Deep-Learning-Historical-Review" class="headerlink" title="Deep Learning ; Historical Review"></a>Deep Learning ; Historical Review</h1><p>사람의 지능을 모방하는 인공지능 AI &gt; data based Machine Learning &gt; Deep Learning (NN을 사용하는)</p>
<br/>

<h2 id="Key-components-of-Deep-learning"><a href="#Key-components-of-Deep-learning" class="headerlink" title="Key components of Deep learning"></a>Key components of Deep learning</h2><ol>
<li>Data that model can learn</li>
<li>Model how to transform data</li>
<li>Loss Function that quantifies the badness of model</li>
<li>Algorithm to adjust the parameters to minimize the Loss Function (최적화 알고리즘)</li>
</ol>
<img src="/assets/images/image-20210201183439274.png" alt="image-20210201183439274" style="zoom: 80%;" />





<h2 id="Historical-Review"><a href="#Historical-Review" class="headerlink" title="Historical Review"></a>Historical Review</h2><br/>

<h3 id="1-AlexNet"><a href="#1-AlexNet" class="headerlink" title="1. AlexNet"></a>1. AlexNet</h3><ul>
<li>224*224의 image data 분류대회에서 처음으로 Deep Learning을 사용하여 1등함</li>
<li>실제적으로 딥러닝의 성능이 입증이 되었던 사실</li>
</ul>
<br/>

<h3 id="2-DQN"><a href="#2-DQN" class="headerlink" title="2. DQN"></a>2. DQN</h3><ul>
<li>Q -Learning의 function estimation에 NN을 추가하여 높은 성능을 이끌어냄</li>
</ul>
<br/>

<h3 id="3-Encoder-Decoder"><a href="#3-Encoder-Decoder" class="headerlink" title="3. Encoder/Decoder"></a>3. Encoder/Decoder</h3><ul>
<li>NLP의 trend가 많이 바뀌었다</li>
</ul>
<br/>

<h3 id="4-Adam-Optimizer"><a href="#4-Adam-Optimizer" class="headerlink" title="4. Adam Optimizer"></a>4. Adam Optimizer</h3><ul>
<li>우리가 optimizer를 선정할때 Adam을 그냥 쓰는 이유가 있을까? 결과가 잘나오는 이유가 있을까?</li>
</ul>
<br/>

<h3 id="5-GAN"><a href="#5-GAN" class="headerlink" title="5. GAN"></a>5. GAN</h3><ul>
<li>Generate Model  : Network가 data를 생성!</li>
</ul>
<br/>

<h3 id="6-RESNET"><a href="#6-RESNET" class="headerlink" title="6. RESNET"></a>6. RESNET</h3><ul>
<li>왜 딥러닝이냐를 설명해주었다</li>
<li>Layer를 더욱더 깊게 쌓을수 있게 만들어줌</li>
</ul>
<br/>

<h3 id="7-Transformer"><a href="#7-Transformer" class="headerlink" title="7. Transformer"></a>7. Transformer</h3><ul>
<li><strong>Attention is all you need!!</strong></li>
<li>모든 기존의 RNN을 대체하였고, 이젠 CNN도 넘보고 있다</li>
</ul>
<br/>

<h3 id="8-BERT-fine-tuned-NLP-model"><a href="#8-BERT-fine-tuned-NLP-model" class="headerlink" title="8. BERT (fine tuned NLP model)"></a>8. BERT (fine tuned NLP model)</h3><ul>
<li>일반적인 단어들로 model을 train한후에 내가 원하는 소수의 data에 fine tunning</li>
<li>OPENAI의 GPT-3</li>
</ul>
<h3 id="9-Self-Supervised-Learning"><a href="#9-Self-Supervised-Learning" class="headerlink" title="9. Self Supervised Learning"></a>9. Self Supervised Learning</h3><ul>
<li>이미지 분류와 같은 분류문제를 풀때 한정된 학습데이터로 model과 loss fun을 바꿔가는게 아닌 학습데이터 외에 라벨을 모르는 Unsupervised Learning 활용</li>
<li>SimCLR</li>
</ul>
<br/>

<h1 id="Neural-Networks"><a href="#Neural-Networks" class="headerlink" title="Neural Networks"></a>Neural Networks</h1><br/>

<p>단순히 Function approximate이다</p>
<p>gradient ascent 라면 reward를 키우도록 ! 이런게 되겠구만</p>
<p>step size $\eta$</p>
<p>행렬을 찾겠다 -&gt; 서로다른 차원의 선형변환을 찾겠다</p>
<p><img src="assets/images/image-20210201202237271.png" alt="image-20210201202237271"></p>
<p>이렇게 그저 연속된 선형변환은 하나의 선형변환으로 합쳐질수 있기 떄문에 층을 여러개 쌓는 이유가 사라진다</p>
<p>따라서 층 중간에 activation function을 넣어준다 -&gt; nonlinear transform</p>
<p>선형결합의 반복이 아닌 nonlinear transform의 결합</p>
<p>더 많은 표현력을 가지게 됨</p>
<br/>

<p>존재성이 중요한게 아니라 표현력이 중요함</p>
<p>MSE는 제곱이라 data 사이에 error가 껴있을때 -&gt; 전체적인 NN이 망가질수도 있음</p>
<p>이렇게 항상 같은 Loss Function을 쓰는게 아니라 상황에 맞게</p>
<p>다른 값에 비해서 그값이 높기만 하면 그 index를 뽑는것 -&gt; 그래서 이걸 수학적으로 CE를 사용함</p>
<h1 id="데이터셋-다루기"><a href="#데이터셋-다루기" class="headerlink" title="데이터셋 다루기"></a>데이터셋 다루기</h1></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-01-28T15:00:00.000Z" title="2020. 1. 29. 오전 12:00:00">2020-01-29</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-04-21T17:34:36.472Z" title="2021. 4. 22. 오전 2:34:36">2021-04-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Boostcamp/">Boostcamp</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/29/2021-01-28-Boostcamp10/">Day10</a></h1><div class="content"><p>Day10 : 확률론2</p>
<h2 id="모수란"><a href="#모수란" class="headerlink" title="모수란?"></a>모수란?</h2><ul>
<li>통계적 모델링은 적절한 가정위에서 확률분포를 추정하는것이 목표!</li>
</ul>
<ul>
<li>데이터는 유한하기 때문에 근사적으로 확률분포를 <span style="color:red">추정</span>할 수 밖에 없다</li>
</ul>
<ul>
<li>데이터가 특정확률분포를 따른다고 선험적으로 가정한 후 그분포를 결정하는 모수(parameter)를 추정하는 방법을 모수적 방법론이라고 한다</li>
</ul>
<ul>
<li>특정확률분포를 가정하지 않고 데이터에 따라 모델의 구조 및 모수의 개수가 유연하게 바뀌면 비모수방법론이다</li>
</ul>
<p><img src="/assets/images/image-20210129113507597.png" alt="image-20210129113507597"></p>
<p>데이터를 생성하는 원리를 먼저 고려하는 것이 원칙 !!!</p>
<h2 id="데이터로-모수를-추정해보자"><a href="#데이터로-모수를-추정해보자" class="headerlink" title="데이터로 모수를 추정해보자!"></a>데이터로 모수를 추정해보자!</h2><ul>
<li><p>표본평균 : 주어진 데이터의 산술평균</p>
<p><img src="/assets/images/image-20210129113753930.png" alt="image-20210129113753930"></p>
</li>
</ul>
<p>​         <strong>N-1로 나누는게 조금 신기하고 다른 점</strong> -&gt; 불편추정량</p>
<h3 id="중요한-개념"><a href="#중요한-개념" class="headerlink" title="중요한 개념"></a>중요한 개념</h3><ul>
<li><p>통계량(표본분산, 표본평균)의 확률분포를 표집분포라부르며(<strong>sampling distribution</strong>)  </p>
<p>이게 좀 신기한게 데이터들의 확률분포는 표본분포(sample distribution)이다</p>
</li>
<li><p>모집단의 확률분포가 정규분포를 따르지 않아도 sample의 갯수를 늘린다면 표본평균의 모집분포는 정규분포를 따른다</p>
</li>
</ul>
<p>가능도의 직관적인 정의 : 확률분포함수의 y값</p>
<ul>
<li>셀 수 있는 사건: <strong>가능도 = 확률</strong></li>
<li>연속 사건: <strong>가능도 ≠≠ 확률, 가능도 = PDF값</strong></li>
<li><img src="/assets/images/image-20210129134031326.png" alt="image-20210129134031326"></li>
<li>수식은 같지만 변수가 다름</li>
</ul>
<h2 id="최대가능도-추정법-MLE"><a href="#최대가능도-추정법-MLE" class="headerlink" title="최대가능도 추정법 (MLE)"></a>최대가능도 추정법 (MLE)</h2><ul>
<li><p>이론적으로 가장 가능성이 높은 모수를 추정하는 방법 중 하나가 바로 MLE다<img src="/assets/images/image-20210129115732709.png" alt="image-20210129115732709"></p>
<p>가능도 함수 : 데이터가 주어진 상황에서 $\theta$를 변형 시킴에 따라 변하는 함수로 이해</p>
<p>즉 조건부 함수와 비슷</p>
<p>그러나 $\theta$에 대한 확률이 아닌 대소비교가 가능한 그냥 함수라고 생각을 하자</p>
</li>
</ul>
<ul>
<li><p>데이터 집합 X가 독립적으로 추출되었을 경우 로그가능도를 최적화 합니다</p>
<p><img src="/assets/images/image-20210129120005351.png" alt="image-20210129120005351"></p>
</li>
</ul>
<ul>
<li>P(x<del>i</del> | $\theta$)의 곱이 풀어서 쓰면 로그들의 곱이라 로그의 합으로 나타낼 수 있다</li>
</ul>
<h2 id="왜-로그가능도를-사용하나요"><a href="#왜-로그가능도를-사용하나요" class="headerlink" title="왜 로그가능도를 사용하나요?"></a>왜 로그가능도를 사용하나요?</h2><p>데이터의 숫자가 졸라 많아지면 컴퓨터의 정확도로는 Likelyhood를 계산하는 것이 불가능하다</p>
<p>따라서 데이터가 독립일 경우 가능도의 곱셈을 가능도의 덧셈으로 바뀌면 컴퓨터로 연산해서 최적화 가능</p>
<p>경사하강법으로 가능도를 최적화할 때 미분 연산을 사용하게 되는데, 로그 가능도를 사용하면 연산량을</p>
<p>O(n^2^)에서 O(n)으로 줄어든다</p>
<p>대개의 손실함수의 경우 gradient descent를 사용하므로, 음의 로그가능도를 최적화하게 된다.</p>
<p>WHY 음의 로그가능도? -&gt; 손실함수를 <strong>최소화</strong> 해야하기 때문에 음의 로그가능도 사용</p>
<h3 id="Ex1-정규분포"><a href="#Ex1-정규분포" class="headerlink" title="Ex1 : 정규분포"></a>Ex1 : 정규분포</h3><p>독립적인 표본을 얻었을 때 최대가능도 추정법을 이용하여 모수를 추정하면</p>
<p><img src="/assets/images/image-20210129120730580.png" alt="image-20210129120730580"></p>
<p> $\theta$($\mu,\sigma$)에 대해 오른쪽 수식을 미분</p>
<p><img src="/assets/images/image-20210129124716185.png" alt="image-20210129124716185"></p>
<p><img src="/assets/images/image-20210129124943621.png" alt="image-20210129124943621"></p>
<p>유도과정을 손으로 도출해보기</p>
<h3 id="Ex2-카테고리-분포"><a href="#Ex2-카테고리-분포" class="headerlink" title="Ex2 : 카테고리 분포"></a>Ex2 : 카테고리 분포</h3><p><img src="/assets/images/image-20210129125236691.png" alt="image-20210129125236691"></p>
<p>카테고리 분포이기 때문에 제약식이 생김</p>
<p>여기서의 모수는 1-d 차원 까지 값이 1또는0이될 확률</p>
<p>모두 더했을때 1이 되어야 하는 제약식이 생긴것</p>
<p>근데 이보다 먼저 가테고리 분포에 대한 이해를 해보자</p>
<p><img src="/assets/images/image-20210129125926914.png" alt="image-20210129125926914"></p>
<p>베르누이 독립시행</p>
<p>동전을 100번 던졌다. 그 중 60번 나왔다. 앞면이 나올 확률이 p(모수)라고 하면 가장 이러한 사건이 일어날 가능도가 높은 p를 구해보면..</p>
<p>일단 100번 던져서 60번 앞면이 나오는 확률 P = 100C60 p^60 (1-p)^40</p>
<p>이러한 확률을 p로 미분했을 때 0이 되는 p값이 P가 최대가 될 떄일 것이며 이것이 MLE로 추정되는 모수 p이다.</p>
<p>로그함수의 성질을 생각했을때 P의 증감은 f(p) =log(p^60 (1-p)^40)과 증감이 같다. 즉 f(p) 가 최대가 될때 P도 최대가 된다.</p>
<p>df/dp = 60/p - 40/(1-p) = 0 , 즉 p = 0.6 일때 f’(p) = 0 이 되며 이것이 우리의 직관과 일치한다. (MLE 끝)</p>
<p><strong>이게 이제 이항분포</strong></p>
<p>전추정 : 0.5값을 가지고 싶어서 던졌는데</p>
<p>구분추정 : 신뢰구간</p>
<p>카테고리 확률분포에서 x데이터가 one hot encoding된 벡터구만</p>
<p>그래서 이렇게 표현하는것이였다</p>
<p><img src="/assets/images/image-20210129130229813.png" alt="image-20210129130229813"></p>
<p>오른쪽 제약식을 만족하면서 왼쪽 목적식을 최대화 -&gt; 최대가능도 추정(MLE)</p>
<p>여기서도 라그랑주가…..</p>
<p>이거 수식전개 해보기</p>
<p><img src="/assets/images/image-20210129131355105.png" alt="image-20210129131355105"></p>
<h2 id="딥러닝에서의-최대가능도-추정법"><a href="#딥러닝에서의-최대가능도-추정법" class="headerlink" title="딥러닝에서의 최대가능도 추정법"></a>딥러닝에서의 최대가능도 추정법</h2><p>딥러닝 모델의 가중치를  $\theta$(W1,W2,W3…,WL)이라 표기했을때 마지막 softmax vector은 카테고리분포의 모수(p<del>1</del>,p<del>2</del>…,p<del>k</del>)를 모델링한다</p>
<p>원핫벡터로 표현된 정답 레이블 y = (y<del>1</del>,y<del>2</del>….,y<del>k</del>)를 관찰데이터로 이용해 확률분포인 소프트멕스 벡터의 로그가능도를 최적화 할 수 있다.</p>
<p><img src="/assets/images/image-20210129131820658.png" alt="image-20210129131820658"></p>
<h2 id="확률분포에서의-거리"><a href="#확률분포에서의-거리" class="headerlink" title="확률분포에서의 거리"></a>확률분포에서의 거리</h2><ul>
<li>기계학습에서 유도되는 Loss function들은 모델이 학습하는 확률분포와 데이터에서 관찰되는 확률분포의 거리를 통해 유도된다</li>
</ul>
<p>두확률분포사이의 거리</p>
<ol>
<li>총변동거리 (Total Variation Distance, TV)</li>
<li>쿨백-라이블러 발산</li>
<li>바슈타인 거리</li>
</ol>
<h3 id="쿨백-라이블러-발산-Kullback-Leibler-Divergence"><a href="#쿨백-라이블러-발산-Kullback-Leibler-Divergence" class="headerlink" title="쿨백-라이블러 발산 (Kullback - Leibler Divergence)"></a>쿨백-라이블러 발산 (Kullback - Leibler Divergence)</h3><p>정의 </p>
<p><img src="/assets/images/image-20210129132132243.png" alt="image-20210129132132243"></p>
<p><img src="/assets/images/image-20210129132207760.png" alt="image-20210129132207760"></p>
<p>졸라리 어렵다</p>
<p>뭔소리인가 도대체 이게</p>
<p>결국은 정답레이블을 P, 모델 예측을 Q라 두면 ? </p>
<p><strong>Log likelihood를 최대화 하는것과 P와 Q사이의 쿨백하이블러 발산의 최소화는 밀접하다??</strong></p>
<p> 두개의 확률분포의 거리를 최소화 한다?</p>
<p>결국 결론은 !!!!!!!!!!!!!</p>
<p>딥러닝 기계학습에서 통계학적인 지식(MLE)들을 사용하여 Loss function을 최소화 시킬수 있다????</p>
<p>피어세션에서 이번 강의에 대한 심도깊은? 토론을 하였다</p>
<p><strong>Further Question</strong></p>
<ol>
<li><p>확률과 가능도의 차이는 무엇일까요? (개념적인 차이, 수식에서의 차이, 확률밀도함수에서의 차이)</p>
</li>
<li><p>확률 대신 가능도를 사용하였을 때의 이점은 어떤 것이 있을까요?</p>
</li>
<li><p>다음의 code snippet은 어떤 확률분포를 나타내는 것일까요? 해당 확률분포에서 변수 theta가 의미할 수 있는 것은 무엇이 있을까요?</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">theta = np.arange(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0.001</span>)</span><br><span class="line">p = theta ** <span class="number">3</span> * (<span class="number">1</span> - theta) ** <span class="number">7</span></span><br><span class="line">plt.plot(theta, p)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>위의 코드를 보자</p>
<p>theta는 0-1 사이에서 0.001의 간격으로 값을 가진다</p>
<p>모든 theta의 합은 1로 이는 결국 확률이다</p>
<p>이번주말에 정리해야 될 것들</p>
<ol>
<li>다양한 확률밀도 함수에대한고찰 </li>
<li>확률과 가능도</li>
<li>가능도에서의 최대가능도 추정법</li>
<li>MLE의 적용 - 정규분포, 이항분포</li>
<li>gradient descent 수식전개</li>
<li>월요일날 발표 (기본적인 kaggle dataset)</li>
<li>back propagation 수식전개</li>
<li>pandas 정리</li>
<li>시각화 도구</li>
</ol>
<p>자 할게 많다</p>
<p>2,3,4의 내용은 피어세션에서 토론했던 내용을 바탕으로 정리해보면 될 듯 싶다</p>
<p>정리와 추가적인 지식들은 따로 category를 만들어 post하겠다</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">Previous</a></div><div class="pagination-next"><a href="/page/3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/profile.png" alt="Won Cho"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Won Cho</p><p class="is-size-6 is-block">결정장애 ESFP의 험난한 일지</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">36</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="/" target="_self" rel="noopener">Home</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/jo-member"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Instagram" href="https://www.instagram.com/jo__member/"><i class="fab fa-instagram"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Boostcamp/"><span class="level-start"><span class="level-item">Boostcamp</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/categories/Further-Q/"><span class="level-start"><span class="level-item">Further_Q</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Mathmatics-for-ML/"><span class="level-start"><span class="level-item">Mathmatics_for_ML</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/PaperReview/"><span class="level-start"><span class="level-item">PaperReview</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/blog/"><span class="level-start"><span class="level-item">blog</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-02T15:00:00.000Z">2021-02-03</time></p><p class="title"><a href="/2021/02/03/2021-02-03-Boostcamp13.1/">Day13) CNN1</a></p><p class="categories"><a href="/categories/Boostcamp/">Boostcamp</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-01T15:00:00.000Z">2021-02-02</time></p><p class="title"><a href="/2021/02/02/2021-02-02-Boostcamp12.1/">Day12) Optimization</a></p><p class="categories"><a href="/categories/Boostcamp/">Boostcamp</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-01-28T15:00:00.000Z">2021-01-29</time></p><p class="title"><a href="/2021/01/29/2021-01-29-week2/">Week2</a></p><p class="categories"><a href="/categories/Further-Q/">Further_Q</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-29T15:00:00.000Z">2020-12-30</time></p><p class="title"><a href="/2020/12/30/2020-12-30-ML&amp;Mathmatics/">Introduction and Motivation</a></p><p class="categories"><a href="/categories/Mathmatics-for-ML/">Mathmatics_for_ML</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-29T15:00:00.000Z">2020-12-30</time></p><p class="title"><a href="/2020/12/30/2020-12-30-ML&amp;Mathmatics2/">Linear Algebra</a></p><p class="categories"><a href="/categories/Mathmatics-for-ML/">Mathmatics_for_ML</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/boj/"><span class="tag">boj</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/book/"><span class="tag">book</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/books/"><span class="tag">books</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/math/"><span class="tag">math</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Jo Member" height="28"></a><p class="is-size-7"><span>&copy; 2021 jo-member</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>